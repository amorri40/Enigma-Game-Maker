/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

#include "../Universal_System/collisions_object.h"

// Script identifiers
const int physics_system_init = 241;
const int physics_init = 242;
const int physics_destroy = 243;
const int physics_import = 244;
const int physics_export = 245;
const int physics_step = 246;
const int physics_draw = 247;
const int physics_settings = 248;
const int physics_motion = 249;
const int physics_position = 250;
const int physics_point_add = 251;
const int physics_point_remove = 252;
const int physics_joint_add = 253;
const int physics_joint_remove = 254;
const int physics_sprite_add = 255;
const int physics_sprite_remove = 256;
const int physics_angle = 257;

#define physics_system_init(arguments...) _SCR_physics_system_init(arguments)
#define physics_init(arguments...) _SCR_physics_init(arguments)
#define physics_destroy(arguments...) _SCR_physics_destroy(arguments)
#define physics_import(arguments...) _SCR_physics_import(arguments)
#define physics_export(arguments...) _SCR_physics_export(arguments)
#define physics_step(arguments...) _SCR_physics_step(arguments)
#define physics_draw(arguments...) _SCR_physics_draw(arguments)
#define physics_settings(arguments...) _SCR_physics_settings(arguments)
#define physics_motion(arguments...) _SCR_physics_motion(arguments)
#define physics_position(arguments...) _SCR_physics_position(arguments)
#define physics_point_add(arguments...) _SCR_physics_point_add(arguments)
#define physics_point_remove(arguments...) _SCR_physics_point_remove(arguments)
#define physics_joint_add(arguments...) _SCR_physics_joint_add(arguments)
#define physics_joint_remove(arguments...) _SCR_physics_joint_remove(arguments)
#define physics_sprite_add(arguments...) _SCR_physics_sprite_add(arguments)
#define physics_sprite_remove(arguments...) _SCR_physics_sprite_remove(arguments)
#define physics_angle(arguments...) _SCR_physics_angle(arguments)


variant _SCR_physics_system_init();
variant _SCR_physics_init();
variant _SCR_physics_destroy();
variant _SCR_physics_import(variant argument0=0, variant argument1=0, variant argument2=0, variant argument3=0, variant argument4=0);
variant _SCR_physics_export();
variant _SCR_physics_step();
variant _SCR_physics_draw(variant argument0=0, variant argument1=0, variant argument2=0);
variant _SCR_physics_settings(variant argument0=0);
variant _SCR_physics_motion(variant argument0=0, variant argument1=0, variant argument2=0, variant argument3=0);
variant _SCR_physics_position();
variant _SCR_physics_point_add();
variant _SCR_physics_point_remove();
variant _SCR_physics_joint_add();
variant _SCR_physics_joint_remove();
variant _SCR_physics_sprite_add();
variant _SCR_physics_sprite_remove();
variant _SCR_physics_angle(variant argument0=0, variant argument1=0);

namespace enigma
{
  struct object_locals: event_parent, virtual extension_alarm
  {
    #include "../Preprocessor_Environment_Editable/IDE_EDIT_inherited_locals.h"

    object_locals() {}
    object_locals(unsigned x, int y): event_parent(x,y) {}
  };
  
  struct OBJ_obj_sprite: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_obj_sprite(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 25)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_obj_sprite()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_obj_object: object_locals
  {
    //Locals to instances of this object
    var fa_center;
    var joint_dist;
    var joint_max;
    var joint_min;
    var joint_numb;
    var joint_point;
    var point_collision;
    var point_friction;
    var point_numb;
    var point_radius;
    var point_stationary;
    var point_x;
    var point_x_prev;
    var point_y;
    var point_y_prev;
    var sprite;
    var sprite_image;
    var sprite_numb;
    var sprite_offset;
    var sprite_point;
    var sprite_solid;
    var sprite_transparent;
    var strength;
    var tempdist;
    
    //Scripts called by this object
    
    variant _SCR_physics_draw(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0);
    variant _SCR_physics_import(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
    variant _SCR_physics_init();
    variant _SCR_physics_motion(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
    variant _SCR_physics_settings(variant argument0 = 0);
    variant _SCR_physics_step();
        variant myevent_create();
        variant myevent_step();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj26;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj26, 26);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_obj_object(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 26)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj26 = enigma::link_obj_instance(this, 26);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_obj_object()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj26;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_obj_track: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj53;
      enigma::inst_iter *ENOBJ_ITER_myobj66;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj53, 53);
      unlink_object_id_iter(ENOBJ_ITER_myobj66, 66);
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_obj_track(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 53)
    {
      sprite_index = 56;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj53 = enigma::link_obj_instance(this, 53);
      ENOBJ_ITER_myobj66 = enigma::link_obj_instance(this, 66);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_obj_track()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj53;
      delete ENOBJ_ITER_myobj66;
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_obj_wall: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj65;
      enigma::inst_iter *ENOBJ_ITER_myobj66;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj65, 65);
      unlink_object_id_iter(ENOBJ_ITER_myobj66, 66);
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_obj_wall(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 65)
    {
      sprite_index = 72;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj65 = enigma::link_obj_instance(this, 65);
      ENOBJ_ITER_myobj66 = enigma::link_obj_instance(this, 66);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_obj_wall()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj65;
      delete ENOBJ_ITER_myobj66;
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_obj_solid: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj66;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj66, 66);
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_obj_solid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 66)
    {
      sprite_index = -1;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj66 = enigma::link_obj_instance(this, 66);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_obj_solid()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj66;
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myevent_step;
    }
  };
}
