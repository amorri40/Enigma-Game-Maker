/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

#include "../Universal_System/collisions_object.h"

// Script identifiers
const int draw_radar = 0;
const int script1 = 1;
const int script3 = 3;
const int textbox = 6;

#define draw_radar(arguments...) _SCR_draw_radar(arguments)
#define script1(arguments...) _SCR_script1(arguments)
#define script3(arguments...) _SCR_script3(arguments)
#define textbox(arguments...) _SCR_textbox(arguments)


variant _SCR_draw_radar(variant argument0=0, variant argument1=0);
variant _SCR_script1();
variant _SCR_script3();
variant _SCR_textbox(variant argument0=0, variant argument1=0, variant argument2=0, variant argument3=0);

namespace enigma
{
  struct object_locals: event_parent, virtual extension_alarm
  {
    #include "../Preprocessor_Environment_Editable/IDE_EDIT_inherited_locals.h"

    object_locals() {}
    object_locals(unsigned x, int y): event_parent(x,y) {}
  };
  
  struct OBJ_tank: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_5();
        variant myevent_collision_21();
        variant myevent_collision_29();
        variant myevent_collision_30();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_43();
        variant myevent_collision_44();
        variant myevent_collision_113();
        variant myevent_collision_114();
        variant myevent_keyboard_0();
        variant myevent_keyboard_13();
        variant myevent_keyboard_16();
        variant myevent_keyboard_37();
        variant myevent_keyboard_38();
        variant myevent_keyboard_39();
        variant myevent_keyboard_40();
        variant myevent_draw();
        variant myevent_keyrelease_13();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(5)) myevent_collision_5();
        if (instance_number(21)) myevent_collision_21();
        if (instance_number(29)) myevent_collision_29();
        if (instance_number(30)) myevent_collision_30();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(43)) myevent_collision_43();
        if (instance_number(44)) myevent_collision_44();
        if (instance_number(113)) myevent_collision_113();
        if (instance_number(114)) myevent_collision_114();
      }
      void myevent_keyboard()
      {
        if (keyboard_check(0)) myevent_keyboard_0();
        if (keyboard_check(13)) myevent_keyboard_13();
        if (keyboard_check(16)) myevent_keyboard_16();
        if (keyboard_check(37)) myevent_keyboard_37();
        if (keyboard_check(38)) myevent_keyboard_38();
        if (keyboard_check(39)) myevent_keyboard_39();
        if (keyboard_check(40)) myevent_keyboard_40();
      }
      void myevent_keyrelease()
      {
        if (keyboard_check_released(13)) myevent_keyrelease_13();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyboard;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyrelease;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_keyboard->unlink(ENOBJ_ITER_myevent_keyboard);
      enigma::event_keyrelease->unlink(ENOBJ_ITER_myevent_keyrelease);
    }
    
    OBJ_tank(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 0)
    {
      sprite_index = 0;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_keyboard = enigma::event_keyboard->add_inst(this);
      ENOBJ_ITER_myevent_keyrelease = enigma::event_keyrelease->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_tank()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_keyboard;
      delete ENOBJ_ITER_myevent_keyrelease;
    }
  };
  
  struct OBJ_turret1: object_locals
  {
    //Locals to instances of this object
    var automatic;
    var can_shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_globalleftbutton();
        variant myevent_globalrightbutton();
        variant myevent_globalmiddlebutton();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj1;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalrightbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalmiddlebutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj1, 1);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      enigma::event_globalrightbutton->unlink(ENOBJ_ITER_myevent_globalrightbutton);
      enigma::event_globalmiddlebutton->unlink(ENOBJ_ITER_myevent_globalmiddlebutton);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_turret1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 1)
    {
      sprite_index = 1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj1 = enigma::link_obj_instance(this, 1);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_globalrightbutton = enigma::event_globalrightbutton->add_inst(this);
      ENOBJ_ITER_myevent_globalmiddlebutton = enigma::event_globalmiddlebutton->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_turret1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj1;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_globalrightbutton;
      delete ENOBJ_ITER_myevent_globalmiddlebutton;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_bullet: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj2;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj2, 2);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_bullet(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 2)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj2 = enigma::link_obj_instance(this, 2);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_bullet()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj2;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_dest: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj3;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj3, 3);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_dest(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 3)
    {
      sprite_index = 41;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj3 = enigma::link_obj_instance(this, 3);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_dest()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj3;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_cursor1: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj4;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj4, 4);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_cursor1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 4)
    {
      sprite_index = 14;
      visible = 1;
      solid = 0;
      depth.init(-5000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj4 = enigma::link_obj_instance(this, 4);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_cursor1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj4;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_baddybullet: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj5;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj5, 5);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 5)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj5 = enigma::link_obj_instance(this, 5);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj5;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_controller: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj6;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj6, 6);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_controller(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 6)
    {
      sprite_index = 41;
      visible = 1;
      solid = 0;
      depth.init(-5000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj6 = enigma::link_obj_instance(this, 6);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_controller()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj6;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_enemy_tank: object_locals
  {
    //Locals to instances of this object
    var ac;
    var b2h;
    var bac;
    var collide;
    var p;
    var rad;
    var sh;
    var snore_rad;
    var t;
    var tankradius;
    var tx;
    var ty;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_0();
        variant myevent_collision_2();
        variant myevent_collision_3();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_15();
        variant myevent_collision_16();
        variant myevent_collision_19();
        variant myevent_collision_25();
        variant myevent_collision_26();
        variant myevent_collision_45();
        variant myevent_collision_46();
        variant myevent_collision_57();
        variant myevent_collision_63();
        variant myevent_boundary();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(2)) myevent_collision_2();
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(15)) myevent_collision_15();
        if (instance_number(16)) myevent_collision_16();
        if (instance_number(19)) myevent_collision_19();
        if (instance_number(25)) myevent_collision_25();
        if (instance_number(26)) myevent_collision_26();
        if (instance_number(45)) myevent_collision_45();
        if (instance_number(46)) myevent_collision_46();
        if (instance_number(57)) myevent_collision_57();
        if (instance_number(63)) myevent_collision_63();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj8;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_boundary;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj8, 8);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_boundary->unlink(ENOBJ_ITER_myevent_boundary);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemy_tank(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 8)
    {
      sprite_index = 8;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj8 = enigma::link_obj_instance(this, 8);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_boundary = enigma::event_boundary->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemy_tank()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj8;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_boundary;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_explosion: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj9;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj9, 9);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_explosion(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 9), $iip(-1)
    {
      sprite_index = 7;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj9 = enigma::link_obj_instance(this, 9);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_explosion()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj9;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_enemyturret: object_locals
  {
    //Locals to instances of this object
    var hold;
    var priority;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_26();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(26)) myevent_collision_26();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj10;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj10, 10);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemyturret(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 10)
    {
      sprite_index = 10;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj10 = enigma::link_obj_instance(this, 10);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemyturret()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj10;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_enemy_tank2: object_locals
  {
    //Locals to instances of this object
    var ac;
    var b2h;
    var bac;
    var p;
    var rad;
    var sh;
    var snore_rad;
    var t;
    var tx;
    var ty;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_0();
        variant myevent_collision_2();
        variant myevent_collision_3();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_15();
        variant myevent_collision_16();
        variant myevent_collision_19();
        variant myevent_collision_25();
        variant myevent_collision_46();
        variant myevent_collision_57();
        variant myevent_collision_63();
        variant myevent_boundary();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(2)) myevent_collision_2();
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(15)) myevent_collision_15();
        if (instance_number(16)) myevent_collision_16();
        if (instance_number(19)) myevent_collision_19();
        if (instance_number(25)) myevent_collision_25();
        if (instance_number(46)) myevent_collision_46();
        if (instance_number(57)) myevent_collision_57();
        if (instance_number(63)) myevent_collision_63();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_boundary;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_boundary->unlink(ENOBJ_ITER_myevent_boundary);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemy_tank2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 11)
    {
      sprite_index = 20;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_boundary = enigma::event_boundary->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemy_tank2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_boundary;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_enemyturret2: object_locals
  {
    //Locals to instances of this object
    var hold;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_26();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(26)) myevent_collision_26();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj13;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj13, 13);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemyturret2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 13)
    {
      sprite_index = 11;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj13 = enigma::link_obj_instance(this, 13);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemyturret2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj13;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_missle_turrret: object_locals
  {
    //Locals to instances of this object
    var an_shoot;
    var can_shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_3();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_globalleftbutton();
        variant myevent_globalrightbutton();
        variant myevent_globalleftrelease();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_3();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj14;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalrightbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftrelease;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj14, 14);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      enigma::event_globalrightbutton->unlink(ENOBJ_ITER_myevent_globalrightbutton);
      enigma::event_globalleftrelease->unlink(ENOBJ_ITER_myevent_globalleftrelease);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_missle_turrret(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 14)
    {
      sprite_index = 57;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj14 = enigma::link_obj_instance(this, 14);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_globalrightbutton = enigma::event_globalrightbutton->add_inst(this);
      ENOBJ_ITER_myevent_globalleftrelease = enigma::event_globalleftrelease->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_missle_turrret()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj14;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_globalrightbutton;
      delete ENOBJ_ITER_myevent_globalleftrelease;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_laser: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj15;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj15, 15);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_laser(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 15)
    {
      sprite_index = 5;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj15 = enigma::link_obj_instance(this, 15);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_laser()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj15;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_missle: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj16;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj16, 16);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_missle(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 16)
    {
      sprite_index = 6;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj16 = enigma::link_obj_instance(this, 16);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_missle()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj16;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_missle_turret: object_locals
  {
    //Locals to instances of this object
    var an_shoot;
    var can_shoo;
    var can_shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_3();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_globalleftbutton();
        variant myevent_globalleftrelease();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_3();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj17;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftrelease;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj17, 17);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      enigma::event_globalleftrelease->unlink(ENOBJ_ITER_myevent_globalleftrelease);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_missle_turret(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 17)
    {
      sprite_index = 57;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj17 = enigma::link_obj_instance(this, 17);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_globalleftrelease = enigma::event_globalleftrelease->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_missle_turret()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj17;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_globalleftrelease;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_enigmaauto: object_locals
  {
    //Locals to instances of this object
    var can_shoo;
    var can_shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_globalleftbutton();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj18;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj18, 18);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enigmaauto(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 18)
    {
      sprite_index = 2;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj18 = enigma::link_obj_instance(this, 18);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enigmaauto()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj18;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_bullet2: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj19;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj19, 19);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_bullet2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 19)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj19 = enigma::link_obj_instance(this, 19);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_bullet2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj19;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_flag: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj20;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj20, 20);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_flag(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 20)
    {
      sprite_index = 23;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj20 = enigma::link_obj_instance(this, 20);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_flag()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj20;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_baddybullet2: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj21;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj21, 21);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 21)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj21 = enigma::link_obj_instance(this, 21);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj21;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_explo2: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj22;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj22, 22);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_explo2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 22), $iip(-1)
    {
      sprite_index = 18;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj22 = enigma::link_obj_instance(this, 22);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_explo2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj22;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_boomtu: object_locals
  {
    //Locals to instances of this object
    var can_shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_globalleftbutton();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj24;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj24, 24);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_boomtu(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 24)
    {
      sprite_index = 19;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj24 = enigma::link_obj_instance(this, 24);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_boomtu()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj24;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_boomlazer: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_boomlazer(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 25)
    {
      sprite_index = 17;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_boomlazer()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_dest2: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj26;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj26, 26);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_dest2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 26)
    {
      sprite_index = 18;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj26 = enigma::link_obj_instance(this, 26);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_dest2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj26;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_enemyturret3: object_locals
  {
    //Locals to instances of this object
    var hold;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_26();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(26)) myevent_collision_26();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj27;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj27, 27);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemyturret3(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 27)
    {
      sprite_index = 25;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj27 = enigma::link_obj_instance(this, 27);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemyturret3()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj27;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baddybullet3: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj29;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj29, 29);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet3(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 29)
    {
      sprite_index = 24;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj29 = enigma::link_obj_instance(this, 29);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet3()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj29;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baddybullet4: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj30;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj30, 30);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 30)
    {
      sprite_index = 27;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj30 = enigma::link_obj_instance(this, 30);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet4()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj30;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_enemyturret4: object_locals
  {
    //Locals to instances of this object
    var hold;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_26();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(26)) myevent_collision_26();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj31;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj31, 31);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemyturret4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 31)
    {
      sprite_index = 26;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj31 = enigma::link_obj_instance(this, 31);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemyturret4()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj31;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_obj_minimap: object_locals
  {
    //Locals to instances of this object
    var _hh;
    var _ww;
    var _xx;
    var _yy;
    var draw_x;
    var draw_y;
    var room_wview;
    
    //Scripts called by this object
    
    variant _SCR_draw_radar(variant argument0 = 0, variant argument1 = 0);
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj33;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj33, 33);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_obj_minimap(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 33)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(-5000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj33 = enigma::link_obj_instance(this, 33);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_obj_minimap()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj33;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_blocko: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj34;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj34, 34);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_blocko(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 34)
    {
      sprite_index = 33;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj34 = enigma::link_obj_instance(this, 34);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_blocko()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj34;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_title: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var soundt;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_animationend();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj35;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj35, 35);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_title(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 35), $iip(-1)
    {
      sprite_index = 39;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj35 = enigma::link_obj_instance(this, 35);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_title()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj35;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_hangars: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj37;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj37, 37);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_hangars(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 37)
    {
      sprite_index = 42;
      visible = 1;
      solid = 0;
      depth.init(5000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj37 = enigma::link_obj_instance(this, 37);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_hangars()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj37;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_HQ: object_locals
  {
    //Locals to instances of this object
    var enigmacontinue;
    var fa_left;
    var fa_top;
    var gamemaker_registered;
    
    //Scripts called by this object
    
    variant _SCR_textbox(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
        variant myevent_collision_2();
        variant myevent_collision_15();
        variant myevent_collision_16();
        variant myevent_collision_19();
        variant myevent_collision_25();
        variant myevent_collision_46();
        variant myevent_collision_57();
        variant myevent_collision_91();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(2)) myevent_collision_2();
        if (instance_number(15)) myevent_collision_15();
        if (instance_number(16)) myevent_collision_16();
        if (instance_number(19)) myevent_collision_19();
        if (instance_number(25)) myevent_collision_25();
        if (instance_number(46)) myevent_collision_46();
        if (instance_number(57)) myevent_collision_57();
        if (instance_number(91)) myevent_collision_91();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj38;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj38, 38);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_HQ(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 38)
    {
      sprite_index = 43;
      visible = 1;
      solid = 0;
      depth.init(5000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj38 = enigma::link_obj_instance(this, 38);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_HQ()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj38;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baseturret: object_locals
  {
    //Locals to instances of this object
    var bth;
    var hold;
    var youcanshoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_alarm_3();
        variant myevent_step();
        variant myevent_collision_2();
        variant myevent_collision_3();
        variant myevent_collision_15();
        variant myevent_collision_16();
        variant myevent_collision_19();
        variant myevent_collision_25();
        variant myevent_collision_26();
        variant myevent_collision_46();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
        myevent_alarm_3();
      }
      void myevent_collision()
      {
        if (instance_number(2)) myevent_collision_2();
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(15)) myevent_collision_15();
        if (instance_number(16)) myevent_collision_16();
        if (instance_number(19)) myevent_collision_19();
        if (instance_number(25)) myevent_collision_25();
        if (instance_number(26)) myevent_collision_26();
        if (instance_number(46)) myevent_collision_46();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj43;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj43, 43);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baseturret(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 43)
    {
      sprite_index = 48;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj43 = enigma::link_obj_instance(this, 43);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baseturret()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj43;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baddybullet5: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj44;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj44, 44);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet5(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 44)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj44 = enigma::link_obj_instance(this, 44);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet5()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj44;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_base: object_locals
  {
    //Locals to instances of this object
    var ac;
    var rad;
    var sh;
    var snore_rad;
    var t;
    var tx;
    var ty;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_boundary();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj45;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_boundary;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj45, 45);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_boundary->unlink(ENOBJ_ITER_myevent_boundary);
      depth.remove();;
    }
    
    OBJ_base(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 45)
    {
      sprite_index = 47;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj45 = enigma::link_obj_instance(this, 45);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_boundary = enigma::event_boundary->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_base()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj45;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_boundary;
    }
  };
  
  struct OBJ_bulletv: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj46;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj46, 46);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_bulletv(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 46)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj46 = enigma::link_obj_instance(this, 46);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_bulletv()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj46;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_someting: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj51;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj51, 51);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_someting(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 51)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj51 = enigma::link_obj_instance(this, 51);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_someting()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj51;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_bullet4: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_68();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj57;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj57, 57);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_bullet4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 57)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj57 = enigma::link_obj_instance(this, 57);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_bullet4()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj57;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_flamb: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj63;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj63, 63);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_flamb(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 63)
    {
      sprite_index = 29;
      visible = 1;
      solid = 0;
      depth.init(-300, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj63 = enigma::link_obj_instance(this, 63);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_flamb()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj63;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_explosionb: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj64;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj64, 64);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_explosionb(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 64), $iip(-1)
    {
      sprite_index = 7;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj64 = enigma::link_obj_instance(this, 64);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_explosionb()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj64;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_smoke: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj65;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj65, 65);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_smoke(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 65), $iip(-1)
    {
      sprite_index = 68;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj65 = enigma::link_obj_instance(this, 65);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_smoke()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj65;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_allie: object_locals
  {
    //Locals to instances of this object
    var ac;
    var b2h;
    var bac;
    var p;
    var rad;
    var sh;
    var snore_rad;
    var t;
    var tx;
    var ty;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_0();
        variant myevent_collision_2();
        variant myevent_collision_3();
        variant myevent_collision_5();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_15();
        variant myevent_collision_16();
        variant myevent_collision_19();
        variant myevent_collision_21();
        variant myevent_collision_25();
        variant myevent_collision_29();
        variant myevent_collision_44();
        variant myevent_collision_46();
        variant myevent_collision_57();
        variant myevent_collision_63();
        variant myevent_collision_68();
        variant myevent_boundary();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(2)) myevent_collision_2();
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(5)) myevent_collision_5();
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(15)) myevent_collision_15();
        if (instance_number(16)) myevent_collision_16();
        if (instance_number(19)) myevent_collision_19();
        if (instance_number(21)) myevent_collision_21();
        if (instance_number(25)) myevent_collision_25();
        if (instance_number(29)) myevent_collision_29();
        if (instance_number(44)) myevent_collision_44();
        if (instance_number(46)) myevent_collision_46();
        if (instance_number(57)) myevent_collision_57();
        if (instance_number(63)) myevent_collision_63();
        if (instance_number(68)) myevent_collision_68();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj68;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_boundary;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj68, 68);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_boundary->unlink(ENOBJ_ITER_myevent_boundary);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_allie(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 68)
    {
      sprite_index = 70;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj68 = enigma::link_obj_instance(this, 68);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_boundary = enigma::event_boundary->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_allie()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj68;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_boundary;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_allie_turret: object_locals
  {
    //Locals to instances of this object
    var hold;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_26();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(26)) myevent_collision_26();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj69;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj69, 69);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_allie_turret(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 69)
    {
      sprite_index = 71;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj69 = enigma::link_obj_instance(this, 69);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_allie_turret()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj69;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_alliedbullet: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj70;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj70, 70);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_alliedbullet(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 70)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj70 = enigma::link_obj_instance(this, 70);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_alliedbullet()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj70;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_mmc1: object_locals
  {
    //Locals to instances of this object
    var enigmacontinue;
    var fa_left;
    var fa_top;
    var gamemaker_registered;
    
    //Scripts called by this object
    
    variant _SCR_textbox(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj73;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj73, 73);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_mmc1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 73)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj73 = enigma::link_obj_instance(this, 73);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_mmc1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj73;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_activator1: object_locals
  {
    //Locals to instances of this object
    var enigmacontinue;
    var fa_left;
    var fa_top;
    var gamemaker_registered;
    var message;
    var range;
    var range2;
    var shoot;
    
    //Scripts called by this object
    
    variant _SCR_textbox(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_83();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(83)) myevent_collision_83();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj79;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj79, 79);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_activator1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 79)
    {
      sprite_index = 75;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj79 = enigma::link_obj_instance(this, 79);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_activator1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj79;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_messenger: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj83;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj83, 83);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_messenger(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 83)
    {
      sprite_index = 75;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj83 = enigma::link_obj_instance(this, 83);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_messenger()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj83;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_tank1: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_5();
        variant myevent_collision_21();
        variant myevent_collision_30();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_44();
        variant myevent_collision_102();
        variant myevent_collision_106();
        variant myevent_collision_109();
        variant myevent_collision_113();
        variant myevent_collision_114();
        variant myevent_keyboard_0();
        variant myevent_keyboard_16();
        variant myevent_keyboard_37();
        variant myevent_keyboard_38();
        variant myevent_keyboard_39();
        variant myevent_keyboard_40();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(5)) myevent_collision_5();
        if (instance_number(21)) myevent_collision_21();
        if (instance_number(30)) myevent_collision_30();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(44)) myevent_collision_44();
        if (instance_number(102)) myevent_collision_102();
        if (instance_number(106)) myevent_collision_106();
        if (instance_number(109)) myevent_collision_109();
        if (instance_number(113)) myevent_collision_113();
        if (instance_number(114)) myevent_collision_114();
      }
      void myevent_keyboard()
      {
        if (keyboard_check(0)) myevent_keyboard_0();
        if (keyboard_check(16)) myevent_keyboard_16();
        if (keyboard_check(37)) myevent_keyboard_37();
        if (keyboard_check(38)) myevent_keyboard_38();
        if (keyboard_check(39)) myevent_keyboard_39();
        if (keyboard_check(40)) myevent_keyboard_40();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj87;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyboard;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj87, 87);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_keyboard->unlink(ENOBJ_ITER_myevent_keyboard);
    }
    
    OBJ_tank1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 87)
    {
      sprite_index = 70;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj87 = enigma::link_obj_instance(this, 87);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_keyboard = enigma::event_keyboard->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_tank1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj87;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_keyboard;
    }
  };
  
  struct OBJ_turret2: object_locals
  {
    //Locals to instances of this object
    var automatic;
    var can_shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_globalleftbutton();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj88;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj88, 88);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_turret2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 88)
    {
      sprite_index = 71;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj88 = enigma::link_obj_instance(this, 88);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_turret2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj88;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_controller2: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj89;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj89, 89);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_controller2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 89)
    {
      sprite_index = 41;
      visible = 1;
      solid = 0;
      depth.init(-5000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj89 = enigma::link_obj_instance(this, 89);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_controller2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj89;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_bullet5: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_8();
        variant myevent_collision_11();
        variant myevent_collision_34();
        variant myevent_collision_37();
        variant myevent_collision_38();
        variant myevent_collision_102();
        variant myevent_collision_104();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(8)) myevent_collision_8();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(34)) myevent_collision_34();
        if (instance_number(37)) myevent_collision_37();
        if (instance_number(38)) myevent_collision_38();
        if (instance_number(102)) myevent_collision_102();
        if (instance_number(104)) myevent_collision_104();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj91;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj91, 91);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_bullet5(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 91)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj91 = enigma::link_obj_instance(this, 91);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_bullet5()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj91;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_activator2: object_locals
  {
    //Locals to instances of this object
    var enigmacontinue;
    var fa_left;
    var fa_top;
    var gamemaker_registered;
    var message;
    var range;
    var range2;
    var shoot;
    
    //Scripts called by this object
    
    variant _SCR_textbox(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_83();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(83)) myevent_collision_83();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj93;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj93, 93);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_activator2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 93)
    {
      sprite_index = 75;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj93 = enigma::link_obj_instance(this, 93);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_activator2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj93;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_activator3: object_locals
  {
    //Locals to instances of this object
    var enigmacontinue;
    var fa_left;
    var fa_top;
    var gamemaker_registered;
    var message;
    var range;
    var range2;
    var shoot;
    
    //Scripts called by this object
    
    variant _SCR_textbox(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_83();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(83)) myevent_collision_83();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj95;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj95, 95);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_activator3(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 95)
    {
      sprite_index = 75;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj95 = enigma::link_obj_instance(this, 95);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_activator3()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj95;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_intro: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_globalleftbutton();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj96;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj96, 96);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_intro(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 96)
    {
      sprite_index = 76;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj96 = enigma::link_obj_instance(this, 96);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_intro()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj96;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_enigmatm: object_locals
  {
    //Locals to instances of this object
    var shoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_globalleftbutton();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj97;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj97, 97);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_enigmatm(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 97)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj97 = enigma::link_obj_instance(this, 97);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enigmatm()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj97;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_tmm: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj98;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj98, 98);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_tmm(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 98)
    {
      sprite_index = 41;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj98 = enigma::link_obj_instance(this, 98);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_tmm()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj98;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_NEW: object_locals
  {
    //Locals to instances of this object
    var NEWV;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_98();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(98)) myevent_collision_98();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj99;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj99, 99);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_NEW(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 99)
    {
      sprite_index = 78;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj99 = enigma::link_obj_instance(this, 99);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_NEW()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj99;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_LOAD: object_locals
  {
    //Locals to instances of this object
    var LOADV;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj100;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj100, 100);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_LOAD(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 100)
    {
      sprite_index = 82;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj100 = enigma::link_obj_instance(this, 100);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_LOAD()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj100;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_OPTION: object_locals
  {
    //Locals to instances of this object
    var OPTIONV;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj101;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj101, 101);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_OPTION(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 101)
    {
      sprite_index = 80;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj101 = enigma::link_obj_instance(this, 101);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_OPTION()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj101;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_dummy: object_locals
  {
    //Locals to instances of this object
    var dh;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_91();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(91)) myevent_collision_91();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj102;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj102, 102);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_dummy(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 102)
    {
      sprite_index = 9;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj102 = enigma::link_obj_instance(this, 102);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_dummy()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj102;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_dummyt: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_3();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj103;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj103, 103);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_dummyt(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 103)
    {
      sprite_index = 21;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj103 = enigma::link_obj_instance(this, 103);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_dummyt()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj103;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_enemy_tankt1: object_locals
  {
    //Locals to instances of this object
    var ac;
    var b2h;
    var bac;
    var collide;
    var p;
    var rad;
    var sh;
    var snore_rad;
    var t;
    var tankradius;
    var tx;
    var ty;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_collision_0();
        variant myevent_collision_2();
        variant myevent_collision_3();
        variant myevent_collision_11();
        variant myevent_collision_19();
        variant myevent_collision_46();
        variant myevent_collision_57();
        variant myevent_collision_87();
        variant myevent_collision_91();
        variant myevent_collision_104();
        variant myevent_collision_107();
        variant myevent_boundary();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(2)) myevent_collision_2();
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(19)) myevent_collision_19();
        if (instance_number(46)) myevent_collision_46();
        if (instance_number(57)) myevent_collision_57();
        if (instance_number(87)) myevent_collision_87();
        if (instance_number(91)) myevent_collision_91();
        if (instance_number(104)) myevent_collision_104();
        if (instance_number(107)) myevent_collision_107();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj104;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_boundary;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj104, 104);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_boundary->unlink(ENOBJ_ITER_myevent_boundary);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemy_tankt1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 104)
    {
      sprite_index = 8;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj104 = enigma::link_obj_instance(this, 104);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_boundary = enigma::event_boundary->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemy_tankt1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj104;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_boundary;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_enemyturrett1: object_locals
  {
    //Locals to instances of this object
    var hold;
    var priority;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_26();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(26)) myevent_collision_26();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj105;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj105, 105);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_enemyturrett1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 105)
    {
      sprite_index = 10;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj105 = enigma::link_obj_instance(this, 105);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_enemyturrett1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj105;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baddybullet6: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_collision_87();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
        if (instance_number(87)) myevent_collision_87();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj106;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj106, 106);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet6(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 106)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj106 = enigma::link_obj_instance(this, 106);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet6()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj106;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baset1: object_locals
  {
    //Locals to instances of this object
    var ac;
    var rad;
    var sh;
    var snore_rad;
    var t;
    var tx;
    var ty;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_boundary();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj107;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_boundary;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj107, 107);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_boundary->unlink(ENOBJ_ITER_myevent_boundary);
      depth.remove();;
    }
    
    OBJ_baset1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 107)
    {
      sprite_index = 47;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj107 = enigma::link_obj_instance(this, 107);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_boundary = enigma::event_boundary->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baset1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj107;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_boundary;
    }
  };
  
  struct OBJ_baseturrett1: object_locals
  {
    //Locals to instances of this object
    var bth;
    var hold;
    var youcanshoot;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_alarm_3();
        variant myevent_step();
        variant myevent_collision_3();
        variant myevent_collision_91();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
        myevent_alarm_3();
      }
      void myevent_collision()
      {
        if (instance_number(3)) myevent_collision_3();
        if (instance_number(91)) myevent_collision_91();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj108;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj108, 108);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baseturrett1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 108)
    {
      sprite_index = 48;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj108 = enigma::link_obj_instance(this, 108);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baseturrett1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj108;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_baddybullet7: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_0();
        variant myevent_collision_68();
        variant myevent_collision_87();
        variant myevent_outsideroom();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(68)) myevent_collision_68();
        if (instance_number(87)) myevent_collision_87();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj109;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj109, 109);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_baddybullet7(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 109)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj109 = enigma::link_obj_instance(this, 109);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_baddybullet7()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj109;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_activator4: object_locals
  {
    //Locals to instances of this object
    var enigmacontinue;
    var fa_left;
    var fa_top;
    var gamemaker_registered;
    var message;
    var range;
    var range2;
    var shoot;
    
    //Scripts called by this object
    
    variant _SCR_textbox(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0);
        variant myevent_create();
        variant myevent_alarm_1();
        variant myevent_step();
        variant myevent_collision_83();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_1();
      }
      void myevent_collision()
      {
        if (instance_number(83)) myevent_collision_83();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj110;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj110, 110);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_activator4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 110)
    {
      sprite_index = 75;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj110 = enigma::link_obj_instance(this, 110);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_activator4()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj110;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_smallblock: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj113;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj113, 113);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_smallblock(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 113)
    {
      sprite_index = 85;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj113 = enigma::link_obj_instance(this, 113);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_smallblock()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj113;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_biggerblock: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj114;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj114, 114);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_biggerblock(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 114)
    {
      sprite_index = 86;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj114 = enigma::link_obj_instance(this, 114);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_create();
    }
    
    ~OBJ_biggerblock()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj114;
      delete ENOBJ_ITER_myevent_step;
    }
  };
}
