/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

#include "../Universal_System/collisions_object.h"

// Script identifiers
const int timeing0 = 0;
const int Data_Write_1 = 1;
const int Data_Read_2 = 2;
const int Data_Close_3 = 3;
const int Title_4 = 4;
const int opening_5 = 5;

#define timeing0(arguments...) _SCR_timeing0(arguments)
#define Data_Write_1(arguments...) _SCR_Data_Write_1(arguments)
#define Data_Read_2(arguments...) _SCR_Data_Read_2(arguments)
#define Data_Close_3(arguments...) _SCR_Data_Close_3(arguments)
#define Title_4(arguments...) _SCR_Title_4(arguments)
#define opening_5(arguments...) _SCR_opening_5(arguments)


variant _SCR_timeing0();
variant _SCR_Data_Write_1();
variant _SCR_Data_Read_2();
variant _SCR_Data_Close_3();
variant _SCR_Title_4(variant argument0=0, variant argument1=0, variant argument2=0, variant argument3=0, variant argument4=0);
variant _SCR_opening_5(variant argument0=0, variant argument1=0, variant argument2=0, variant argument3=0, variant argument4=0);

namespace enigma
{
  struct object_locals: event_parent, virtual extension_alarm
  {
    #include "../Preprocessor_Environment_Editable/IDE_EDIT_inherited_locals.h"

    object_locals() {}
    object_locals(unsigned x, int y): event_parent(x,y) {}
  };
  
  struct OBJ_Block: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_Block(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 0)
    {
      sprite_index = 1;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Block()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_Curve1: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj1;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj1, 1);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_Curve1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 1)
    {
      sprite_index = 2;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj1 = enigma::link_obj_instance(this, 1);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Curve1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj1;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_Curve2: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj2;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj2, 2);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_Curve2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 2)
    {
      sprite_index = 3;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj2 = enigma::link_obj_instance(this, 2);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Curve2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj2;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_sprCurve3: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj3;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj3, 3);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_sprCurve3(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 3)
    {
      sprite_index = 4;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj3 = enigma::link_obj_instance(this, 3);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_sprCurve3()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj3;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_Curve4: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj4;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj4, 4);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_Curve4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 4)
    {
      sprite_index = 5;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj4 = enigma::link_obj_instance(this, 4);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Curve4()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj4;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_RoofCurve: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj5;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj5, 5);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_RoofCurve(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 5)
    {
      sprite_index = 8;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj5 = enigma::link_obj_instance(this, 5);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_RoofCurve()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj5;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_Player: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var angle;
    var bonus;
    var cr;
    var dash;
    var enigmawait;
    var fast;
    var g;
    var grinding;
    var hspd;
    var i;
    var inair;
    var jmp;
    var jog;
    var on;
    var psh;
    var r;
    var radians;
    var run;
    var skid;
    var slep;
    var sp;
    var spd;
    var stp;
    var tempA1;
    var tempA2;
    var vspd;
    var walk;
    var wateron;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_6();
        variant myevent_step();
        variant myevent_endstep();
        variant myevent_collision_0();
        variant myevent_collision_11();
        variant myevent_collision_17();
        variant myevent_collision_56();
        variant myevent_collision_57();
        variant myevent_keyboard_1();
        variant myevent_keyboard_37();
        variant myevent_keyboard_39();
        variant myevent_globalleftbutton();
        variant myevent_globalrightbutton();
        variant myevent_roomstart();
        variant myevent_animationend();
        variant myevent_draw();
        variant myevent_keypress_90();
        variant myevent_keyrelease_90();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_6();
      }
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(11)) myevent_collision_11();
        if (instance_number(17)) myevent_collision_17();
        if (instance_number(56)) myevent_collision_56();
        if (instance_number(57)) myevent_collision_57();
      }
      void myevent_keyboard()
      {
        if (keyboard_check(1)) myevent_keyboard_1();
        if (keyboard_check(37)) myevent_keyboard_37();
        if (keyboard_check(39)) myevent_keyboard_39();
      }
      void myevent_keypress()
      {
        if (keyboard_check_pressed(90)) myevent_keypress_90();
      }
      void myevent_keyrelease()
      {
        if (keyboard_check_released(90)) myevent_keyrelease_90();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj6;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalrightbutton;
      enigma::inst_iter *ENOBJ_ITER_myevent_roomstart;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyboard;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypress;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyrelease;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj6, 6);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_globalleftbutton->unlink(ENOBJ_ITER_myevent_globalleftbutton);
      enigma::event_globalrightbutton->unlink(ENOBJ_ITER_myevent_globalrightbutton);
      enigma::event_roomstart->unlink(ENOBJ_ITER_myevent_roomstart);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_keyboard->unlink(ENOBJ_ITER_myevent_keyboard);
      enigma::event_keypress->unlink(ENOBJ_ITER_myevent_keypress);
      enigma::event_keyrelease->unlink(ENOBJ_ITER_myevent_keyrelease);
    }
    
    OBJ_Player(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 6), $iip(-1)
    {
      sprite_index = 10;
      visible = 1;
      solid = 0;
      depth.init(-1, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj6 = enigma::link_obj_instance(this, 6);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_globalleftbutton = enigma::event_globalleftbutton->add_inst(this);
      ENOBJ_ITER_myevent_globalrightbutton = enigma::event_globalrightbutton->add_inst(this);
      ENOBJ_ITER_myevent_roomstart = enigma::event_roomstart->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_keyboard = enigma::event_keyboard->add_inst(this);
      ENOBJ_ITER_myevent_keypress = enigma::event_keypress->add_inst(this);
      ENOBJ_ITER_myevent_keyrelease = enigma::event_keyrelease->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Player()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj6;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_globalleftbutton;
      delete ENOBJ_ITER_myevent_globalrightbutton;
      delete ENOBJ_ITER_myevent_roomstart;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_keyboard;
      delete ENOBJ_ITER_myevent_keypress;
      delete ENOBJ_ITER_myevent_keyrelease;
    }
  };
  
  struct OBJ_AngleLeft: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_alarm_7();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj7;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj7, 7);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_AngleLeft(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 7)
    {
      sprite_index = 6;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj7 = enigma::link_obj_instance(this, 7);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_AngleLeft()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj7;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_AngleRight: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_alarm_7();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj8;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj8, 8);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_AngleRight(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 8)
    {
      sprite_index = 6;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj8 = enigma::link_obj_instance(this, 8);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_AngleRight()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj8;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_Credit: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj9;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj9, 9);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_Credit(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 9)
    {
      sprite_index = 9;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj9 = enigma::link_obj_instance(this, 9);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Credit()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj9;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_afterimage: object_locals
  {
    //Locals to instances of this object
    var angle;
    var bonus;
    var col;
    var cr;
    var dash;
    var fast;
    var grinding;
    var jmp;
    var jog;
    var psh;
    var r;
    var run;
    var skid;
    var slep;
    var stp;
    var walk;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj10;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj10, 10);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_afterimage(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 10)
    {
      sprite_index = 14;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj10 = enigma::link_obj_instance(this, 10);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_afterimage()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj10;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_rail2: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_rail2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 11)
    {
      sprite_index = 43;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_rail2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_spark: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj12;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj12, 12);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
    }
    
    OBJ_spark(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 12), $iip(-1)
    {
      sprite_index = 19;
      visible = 1;
      solid = 0;
      depth.init(-2, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj12 = enigma::link_obj_instance(this, 12);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_spark()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj12;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_animationend;
    }
  };
  
  struct OBJ_rail3: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj13;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj13, 13);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_rail3(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 13)
    {
      sprite_index = 41;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj13 = enigma::link_obj_instance(this, 13);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_rail3()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj13;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_rail1: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj14;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj14, 14);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_rail1(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 14)
    {
      sprite_index = 42;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj14 = enigma::link_obj_instance(this, 14);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_rail1()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj14;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_rail4: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj15;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj15, 15);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_rail4(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 15)
    {
      sprite_index = 39;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj15 = enigma::link_obj_instance(this, 15);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_rail4()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj15;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_dust: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj16;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj16, 16);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_dust(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 16), $iip(-1)
    {
      sprite_index = 23;
      visible = 1;
      solid = 0;
      depth.init(-2, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj16 = enigma::link_obj_instance(this, 16);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_dust()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj16;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_loopleft: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_alarm_7();
        variant myevent_step();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj17;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj17, 17);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_loopleft(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 17)
    {
      sprite_index = 24;
      visible = 1;
      solid = 0;
      depth.init(2e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj17 = enigma::link_obj_instance(this, 17);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_loopleft()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj17;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_loopright: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_alarm_7();
        variant myevent_step();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj18;
      enigma::inst_iter *ENOBJ_ITER_myobj17;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj18, 18);
      unlink_object_id_iter(ENOBJ_ITER_myobj17, 17);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_loopright(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 18)
    {
      sprite_index = 25;
      visible = 1;
      solid = 0;
      depth.init(-3, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj18 = enigma::link_obj_instance(this, 18);
      ENOBJ_ITER_myobj17 = enigma::link_obj_instance(this, 17);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_loopright()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj18;
      delete ENOBJ_ITER_myobj17;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_looptop: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj19;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj19, 19);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_looptop(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 19)
    {
      sprite_index = 26;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj19 = enigma::link_obj_instance(this, 19);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_looptop()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj19;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_loopbottom: object_locals
  {
    //Locals to instances of this object
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_7();
        variant myevent_step();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj20;
      enigma::inst_iter *ENOBJ_ITER_myobj21;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj20, 20);
      unlink_object_id_iter(ENOBJ_ITER_myobj21, 21);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_loopbottom(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 20)
    {
      sprite_index = 27;
      visible = 0;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj20 = enigma::link_obj_instance(this, 20);
      ENOBJ_ITER_myobj21 = enigma::link_obj_instance(this, 21);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_loopbottom()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj20;
      delete ENOBJ_ITER_myobj21;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_flatfloor: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj21;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj21, 21);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_flatfloor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 21)
    {
      sprite_index = 28;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj21 = enigma::link_obj_instance(this, 21);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_flatfloor()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj21;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object22: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj22;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj22, 22);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object22(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 22)
    {
      sprite_index = 29;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj22 = enigma::link_obj_instance(this, 22);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object22()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj22;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object23: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj23;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj23, 23);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object23(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 23)
    {
      sprite_index = 30;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj23 = enigma::link_obj_instance(this, 23);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object23()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj23;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object24: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj24;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj24, 24);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object24(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 24)
    {
      sprite_index = 31;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj24 = enigma::link_obj_instance(this, 24);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object24()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj24;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object25: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj25;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj25, 25);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object25(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 25)
    {
      sprite_index = 32;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj25 = enigma::link_obj_instance(this, 25);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object25()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj25;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_flatrail: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_alarm_7();
        variant myevent_endstep();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj26;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj26, 26);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_flatrail(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 26)
    {
      sprite_index = 36;
      visible = 1;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj26 = enigma::link_obj_instance(this, 26);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_flatrail()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj26;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_downrail: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj27;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj27, 27);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_downrail(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 27)
    {
      sprite_index = 37;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj27 = enigma::link_obj_instance(this, 27);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_downrail()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj27;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_raildl: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj28;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj28, 28);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_raildl(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 28)
    {
      sprite_index = 38;
      visible = 1;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj28 = enigma::link_obj_instance(this, 28);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_raildl()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj28;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_raildr: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj29;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj29, 29);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_raildr(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 29)
    {
      sprite_index = 35;
      visible = 1;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj29 = enigma::link_obj_instance(this, 29);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_raildr()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj29;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object30: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj30;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj30, 30);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object30(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 30)
    {
      sprite_index = 44;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj30 = enigma::link_obj_instance(this, 30);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object30()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj30;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_goleft: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj31;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj31, 31);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_goleft(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 31)
    {
      sprite_index = 45;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj31 = enigma::link_obj_instance(this, 31);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_goleft()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj31;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object32: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj32;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj32, 32);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object32(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 32)
    {
      sprite_index = 36;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj32 = enigma::link_obj_instance(this, 32);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object32()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj32;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_city: object_locals
  {
    //Locals to instances of this object
    var bh;
    var bonus;
    var bw;
    var mx2vc;
    var mx2y;
    var mxvc;
    var mxy;
    var orgn;
    var orgn2y;
    var orgny;
    var vc;
    var vcy;
    var vx;
    var vxp;
    var vy;
    var vyp;
    var y2diff;
    var ydiff;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj33;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj33, 33);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_city(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 33)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(1e+08, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj33 = enigma::link_obj_instance(this, 33);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_city()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj33;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_gotop: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj34;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj34, 34);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_gotop(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 34)
    {
      sprite_index = 45;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj34 = enigma::link_obj_instance(this, 34);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_gotop()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj34;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_train: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj35;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj35, 35);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_train(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 35)
    {
      sprite_index = 47;
      visible = 1;
      solid = 0;
      depth.init(1000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj35 = enigma::link_obj_instance(this, 35);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_train()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj35;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_ramp: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj36;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj36, 36);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_ramp(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 36)
    {
      sprite_index = 48;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj36 = enigma::link_obj_instance(this, 36);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_ramp()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj36;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_hud: object_locals
  {
    //Locals to instances of this object
    var current_time;
    var deltaTime;
    var fa_left;
    var fa_top;
    var fs;
    var hundred0pad;
    var hundreds;
    var minutes;
    var second0pad;
    var seconds;
    var startingTime;
    
    //Scripts called by this object
    
    variant _SCR_timeing0();
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj37;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj37, 37);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_hud(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 37)
    {
      sprite_index = 51;
      visible = 1;
      solid = 0;
      depth.init(-1e+06, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj37 = enigma::link_obj_instance(this, 37);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_hud()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj37;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_object38: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_collision_6();
        variant myevent_animationend();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj38;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj38, 38);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_object38(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 38), $iip(-1)
    {
      sprite_index = 56;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj38 = enigma::link_obj_instance(this, 38);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object38()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj38;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_looprailR: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj39;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj39, 39);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_looprailR(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 39)
    {
      sprite_index = 43;
      visible = 0;
      solid = 0;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj39 = enigma::link_obj_instance(this, 39);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_looprailR()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj39;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_looprailL: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj40;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj40, 40);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_looprailL(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 40)
    {
      sprite_index = 42;
      visible = 0;
      solid = 0;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj40 = enigma::link_obj_instance(this, 40);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_looprailL()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj40;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_raildownSOLID: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj41;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj41, 41);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_raildownSOLID(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 41)
    {
      sprite_index = 37;
      visible = 0;
      solid = 1;
      depth.init(1e+06, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj41 = enigma::link_obj_instance(this, 41);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_raildownSOLID()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj41;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object42: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_collision_6();
        variant myevent_animationend();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj42;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj42, 42);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_object42(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 42), $iip(-1)
    {
      sprite_index = 57;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj42 = enigma::link_obj_instance(this, 42);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object42()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj42;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_goright: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj43;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj43, 43);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_goright(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 43)
    {
      sprite_index = 45;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj43 = enigma::link_obj_instance(this, 43);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_goright()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj43;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_gobottom: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj44;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj44, 44);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_gobottom(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 44)
    {
      sprite_index = 45;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj44 = enigma::link_obj_instance(this, 44);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_gobottom()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj44;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_railflatSOLID: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj45;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj45, 45);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_railflatSOLID(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 45)
    {
      sprite_index = 36;
      visible = 1;
      solid = 1;
      depth.init(11, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj45 = enigma::link_obj_instance(this, 45);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_railflatSOLID()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj45;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_xtralife: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var busted;
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_6();
        variant myevent_animationend();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj46;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj46, 46);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_xtralife(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 46), $iip(-1)
    {
      sprite_index = 58;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj46 = enigma::link_obj_instance(this, 46);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_xtralife()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj46;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_canyon: object_locals
  {
    //Locals to instances of this object
    var a;
    var bh;
    var bw;
    var h;
    var i;
    var mx2vc;
    var mx2y;
    var mxvc;
    var mxy;
    var orgn0;
    var orgn1;
    var orgn2;
    var orgn2y;
    var orgn3;
    var orgn4;
    var orgn5;
    var orgn6;
    var orgn7;
    var orgn8;
    var orgn9;
    var orgny;
    var vc;
    var vcy;
    var vx;
    var vxp;
    var vy;
    var vyp;
    var w;
    var y2diff;
    var ydiff;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_11();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_11();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj47;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj47, 47);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_canyon(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 47)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(1e+08, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj47 = enigma::link_obj_instance(this, 47);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_canyon()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj47;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_looprailTL: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj48;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj48, 48);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_looprailTL(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 48)
    {
      sprite_index = 39;
      visible = 0;
      solid = 0;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj48 = enigma::link_obj_instance(this, 48);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_looprailTL()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj48;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_looprailTR: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj49;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj49, 49);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_looprailTR(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 49)
    {
      sprite_index = 41;
      visible = 0;
      solid = 0;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj49 = enigma::link_obj_instance(this, 49);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_looprailTR()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj49;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_miniSolid: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj50;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj50, 50);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_miniSolid(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 50)
    {
      sprite_index = 60;
      visible = 0;
      solid = 1;
      depth.init(11, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj50 = enigma::link_obj_instance(this, 50);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_miniSolid()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj50;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_elevator: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj51;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj51, 51);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_elevator(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 51)
    {
      sprite_index = 8;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj51 = enigma::link_obj_instance(this, 51);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_elevator()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj51;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_stopper: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj52;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj52, 52);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_stopper(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 52)
    {
      sprite_index = 46;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj52 = enigma::link_obj_instance(this, 52);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_stopper()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj52;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_elevatoredge: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj53;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj53, 53);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_elevatoredge(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 53)
    {
      sprite_index = 45;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj53 = enigma::link_obj_instance(this, 53);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_elevatoredge()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj53;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_emerald: object_locals
  {
    //Locals to instances of this object
    var move;
    var nx;
    var orbit;
    var u;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_beginstep();
        variant myevent_endstep();
        variant myevent_collision_6();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj54;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_beginstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj54, 54);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_beginstep->unlink(ENOBJ_ITER_myevent_beginstep);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_emerald(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 54)
    {
      sprite_index = 61;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj54 = enigma::link_obj_instance(this, 54);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_beginstep = enigma::event_beginstep->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_emerald()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj54;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_beginstep;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_emeralddust: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj55;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj55, 55);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_emeralddust(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 55), $iip(-1)
    {
      sprite_index = 62;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj55 = enigma::link_obj_instance(this, 55);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_emeralddust()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj55;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_specialring: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_destroy();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj56;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_destroy;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj56, 56);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_destroy->unlink(ENOBJ_ITER_myevent_destroy);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_specialring(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 56)
    {
      sprite_index = 51;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj56 = enigma::link_obj_instance(this, 56);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_destroy = enigma::event_destroy->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_specialring()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj56;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_destroy;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object57: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj57;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj57, 57);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object57(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 57)
    {
      sprite_index = 1;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj57 = enigma::link_obj_instance(this, 57);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object57()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj57;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_badsonic: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_outsideroom();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj58;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj58, 58);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_badsonic(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 58)
    {
      sprite_index = 63;
      visible = 1;
      solid = 0;
      depth.init(-1e+06, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj58 = enigma::link_obj_instance(this, 58);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_badsonic()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj58;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_outsideroom;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_movingfloor: object_locals
  {
    //Locals to instances of this object
    var bonus;
    var bw;
    var orgn;
    var vc;
    var vx;
    var vxp;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj59;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj59, 59);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_movingfloor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 59)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj59 = enigma::link_obj_instance(this, 59);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_movingfloor()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj59;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_wall: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj60;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj60, 60);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_wall(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 60)
    {
      sprite_index = 64;
      visible = 0;
      solid = 0;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj60 = enigma::link_obj_instance(this, 60);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_wall()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj60;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_curvetopleft: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj61;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj61, 61);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_curvetopleft(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 61)
    {
      sprite_index = 15;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj61 = enigma::link_obj_instance(this, 61);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_curvetopleft()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj61;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object62: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj62;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj62, 62);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object62(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 62)
    {
      sprite_index = 65;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj62 = enigma::link_obj_instance(this, 62);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object62()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj62;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object63: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj63;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj63, 63);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object63(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 63)
    {
      sprite_index = 20;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj63 = enigma::link_obj_instance(this, 63);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object63()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj63;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object64: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj64;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj64, 64);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object64(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 64)
    {
      sprite_index = 21;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj64 = enigma::link_obj_instance(this, 64);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object64()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj64;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object65: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj65;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj65, 65);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object65(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 65)
    {
      sprite_index = 22;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj65 = enigma::link_obj_instance(this, 65);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object65()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj65;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object66: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_collision_6();
        variant myevent_animationend();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj66;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj66, 66);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_object66(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 66), $iip(-1)
    {
      sprite_index = 55;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj66 = enigma::link_obj_instance(this, 66);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object66()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj66;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_object67: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj67;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj67, 67);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object67(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 67)
    {
      sprite_index = 5;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj67 = enigma::link_obj_instance(this, 67);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object67()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj67;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object68: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj68;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj68, 68);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object68(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 68)
    {
      sprite_index = 3;
      visible = 0;
      solid = 0;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj68 = enigma::link_obj_instance(this, 68);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object68()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj68;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object69: object_locals
  {
    //Locals to instances of this object
    var on;
    var p;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_outsideroom();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj69;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_outsideroom;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj69, 69);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_outsideroom->unlink(ENOBJ_ITER_myevent_outsideroom);
      depth.remove();;
    }
    
    OBJ_object69(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 69)
    {
      sprite_index = 2;
      visible = 1;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj69 = enigma::link_obj_instance(this, 69);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_outsideroom = enigma::event_outsideroom->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object69()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj69;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_outsideroom;
    }
  };
  
  struct OBJ_movie: object_locals
  {
    //Locals to instances of this object
    var angle;
    var bonus;
    var cr;
    var dash;
    var fast;
    var grinding;
    var i;
    var jmp;
    var jog;
    var on;
    var psh;
    var r;
    var radians;
    var run;
    var skid;
    var slep;
    var sp;
    var spd;
    var stp;
    var tempA1;
    var tempA2;
    var vspd;
    var walk;
    var wateron;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_endstep();
        variant myevent_globalleftpress();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj70;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_globalleftpress;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj70, 70);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_globalleftpress->unlink(ENOBJ_ITER_myevent_globalleftpress);
      depth.remove();;
    }
    
    OBJ_movie(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 70)
    {
      sprite_index = 66;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj70 = enigma::link_obj_instance(this, 70);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_globalleftpress = enigma::event_globalleftpress->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_movie()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj70;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_globalleftpress;
    }
  };
  
  struct OBJ_Rail_Canyon: object_locals
  {
    //Locals to instances of this object
    var col;
    var fa_center;
    var fa_middle;
    var font;
    var nx;
    
    //Scripts called by this object
    
    variant _SCR_Title_4(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj71;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj71, 71);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_Rail_Canyon(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 71)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj71 = enigma::link_obj_instance(this, 71);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Rail_Canyon()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj71;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_Route_99: object_locals
  {
    //Locals to instances of this object
    var col;
    var fa_center;
    var fa_middle;
    var font;
    var nx;
    
    //Scripts called by this object
    
    variant _SCR_Title_4(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj72;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj72, 72);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_Route_99(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 72)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj72 = enigma::link_obj_instance(this, 72);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Route_99()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj72;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_Special___Stage: object_locals
  {
    //Locals to instances of this object
    var col;
    var fa_center;
    var fa_middle;
    var font;
    var nx;
    
    //Scripts called by this object
    
    variant _SCR_Title_4(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj73;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj73, 73);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_Special___Stage(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 73)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj73 = enigma::link_obj_instance(this, 73);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Special___Stage()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj73;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_intro: object_locals
  {
    //Locals to instances of this object
    var c;
    var f;
    var grd;
    var sky;
    var tex;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_7();
        variant myevent_endstep();
        variant myevent_roomend();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj74;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_roomend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj74, 74);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_roomend->unlink(ENOBJ_ITER_myevent_roomend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_intro(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 74)
    {
      sprite_index = 69;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj74 = enigma::link_obj_instance(this, 74);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_roomend = enigma::event_roomend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_intro()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj74;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_roomend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_titlescreen: object_locals
  {
    //Locals to instances of this object
    var alpha;
    var go;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_draw();
        variant myevent_keypress_13();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
      void myevent_keypress()
      {
        if (keyboard_check_pressed(13)) myevent_keypress_13();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj75;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypress;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj75, 75);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypress->unlink(ENOBJ_ITER_myevent_keypress);
    }
    
    OBJ_titlescreen(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 75)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj75 = enigma::link_obj_instance(this, 75);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypress = enigma::event_keypress->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_titlescreen()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj75;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypress;
    }
  };
  
  struct OBJ_knuckles: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var angle;
    var ani;
    var bonus;
    var cr;
    var dash;
    var enigmawait;
    var fast;
    var grinding;
    var hspd;
    var i;
    var inair;
    var jmp;
    var jog;
    var jp;
    var on;
    var psh;
    var r;
    var radians;
    var run;
    var skid;
    var slep;
    var sp;
    var spd;
    var stp;
    var tempA1;
    var tempA2;
    var vspd;
    var walk;
    var wateron;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_6();
        variant myevent_step();
        variant myevent_endstep();
        variant myevent_animationend();
        variant myevent_draw();
        variant myevent_keypress_90();
        variant myevent_keyrelease_90();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_6();
      }
      void myevent_keypress()
      {
        if (keyboard_check_pressed(90)) myevent_keypress_90();
      }
      void myevent_keyrelease()
      {
        if (keyboard_check_released(90)) myevent_keyrelease_90();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj76;
      enigma::inst_iter *ENOBJ_ITER_myobj6;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypress;
      enigma::inst_iter *ENOBJ_ITER_myevent_keyrelease;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj76, 76);
      unlink_object_id_iter(ENOBJ_ITER_myobj6, 6);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypress->unlink(ENOBJ_ITER_myevent_keypress);
      enigma::event_keyrelease->unlink(ENOBJ_ITER_myevent_keyrelease);
    }
    
    OBJ_knuckles(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 76), $iip(-1)
    {
      sprite_index = 73;
      visible = 1;
      solid = 0;
      depth.init(-1, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj76 = enigma::link_obj_instance(this, 76);
      ENOBJ_ITER_myobj6 = enigma::link_obj_instance(this, 6);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypress = enigma::event_keypress->add_inst(this);
      ENOBJ_ITER_myevent_keyrelease = enigma::event_keyrelease->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_knuckles()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj76;
      delete ENOBJ_ITER_myobj6;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypress;
      delete ENOBJ_ITER_myevent_keyrelease;
    }
  };
  
  struct OBJ_afterimageknux: object_locals
  {
    //Locals to instances of this object
    var angle;
    var bonus;
    var col;
    var cr;
    var dash;
    var fast;
    var grinding;
    var jmp;
    var jog;
    var psh;
    var r;
    var run;
    var skid;
    var slep;
    var stp;
    var walk;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj77;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj77, 77);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_afterimageknux(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 77)
    {
      sprite_index = 76;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj77 = enigma::link_obj_instance(this, 77);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_afterimageknux()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj77;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_playerpick: object_locals
  {
    //Locals to instances of this object
    var imgk;
    var imgs;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_draw();
        variant myevent_keypress_13();
        variant myevent_keypress_37();
        variant myevent_keypress_39();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_keypress()
      {
        if (keyboard_check_pressed(13)) myevent_keypress_13();
        if (keyboard_check_pressed(37)) myevent_keypress_37();
        if (keyboard_check_pressed(39)) myevent_keypress_39();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj78;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypress;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj78, 78);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_keypress->unlink(ENOBJ_ITER_myevent_keypress);
    }
    
    OBJ_playerpick(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 78)
    {
      sprite_index = 82;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj78 = enigma::link_obj_instance(this, 78);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_keypress = enigma::event_keypress->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_playerpick()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj78;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_keypress;
    }
  };
  
  struct OBJ_big_79: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj79;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj79, 79);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_big_79(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 79)
    {
      sprite_index = 87;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj79 = enigma::link_obj_instance(this, 79);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_big_79()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj79;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_big_80: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj80;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj80, 80);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_big_80(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 80)
    {
      sprite_index = 86;
      visible = 1;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj80 = enigma::link_obj_instance(this, 80);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_big_80()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj80;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object81: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj81;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj81, 81);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object81(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 81)
    {
      sprite_index = 88;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj81 = enigma::link_obj_instance(this, 81);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object81()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj81;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object82: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj82;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj82, 82);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object82(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 82)
    {
      sprite_index = 89;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj82 = enigma::link_obj_instance(this, 82);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object82()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj82;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object83: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj83;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj83, 83);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object83(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 83)
    {
      sprite_index = 90;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj83 = enigma::link_obj_instance(this, 83);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object83()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj83;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object84: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj84;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj84, 84);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object84(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 84)
    {
      sprite_index = 91;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj84 = enigma::link_obj_instance(this, 84);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object84()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj84;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object85: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj85;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj85, 85);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_object85(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 85)
    {
      sprite_index = 92;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj85 = enigma::link_obj_instance(this, 85);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object85()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj85;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_spike_shield: object_locals
  {
    //Locals to instances of this object
    var angle;
    var col;
    var s;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_endstep();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj86;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj86, 86);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_spike_shield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 86)
    {
      sprite_index = 93;
      visible = 1;
      solid = 0;
      depth.init(-20, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj86 = enigma::link_obj_instance(this, 86);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_spike_shield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj86;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_electricshield: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var busted;
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_6();
        variant myevent_animationend();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj87;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj87, 87);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_electricshield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 87), $iip(-1)
    {
      sprite_index = 58;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj87 = enigma::link_obj_instance(this, 87);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_electricshield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj87;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_electric_shield: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_endstep();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj88;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj88, 88);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_electric_shield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 88)
    {
      sprite_index = 96;
      visible = 1;
      solid = 0;
      depth.init(-20, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj88 = enigma::link_obj_instance(this, 88);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_electric_shield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj88;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_object89: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_animationend();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj89;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj89, 89);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_object89(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 89), $iip(-1)
    {
      sprite_index = 95;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj89 = enigma::link_obj_instance(this, 89);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object89()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj89;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_spikeshield: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var busted;
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_6();
        variant myevent_animationend();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj90;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj90, 90);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_spikeshield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 90), $iip(-1)
    {
      sprite_index = 58;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj90 = enigma::link_obj_instance(this, 90);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_spikeshield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj90;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_rocky: object_locals
  {
    //Locals to instances of this object
    var bh;
    var bw;
    var mx2vc;
    var mx2y;
    var mxvc;
    var mxy;
    var orgn0;
    var orgn1;
    var orgn2;
    var orgn2y;
    var orgn3;
    var orgn4;
    var orgn5;
    var orgn6;
    var orgn7;
    var orgn8;
    var orgn9;
    var orgny;
    var vc;
    var vcy;
    var vx;
    var vxp;
    var vy;
    var vyp;
    var y2diff;
    var ydiff;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj91;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj91, 91);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_rocky(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 91)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(1e+08, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj91 = enigma::link_obj_instance(this, 91);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_rocky()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj91;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_rocky2: object_locals
  {
    //Locals to instances of this object
    var bh;
    var bonus;
    var bw;
    var mx2vc;
    var mx2y;
    var mxvc;
    var mxy;
    var orgn;
    var orgny;
    var vc;
    var vcy;
    var vx;
    var vxp;
    var vy;
    var vyp;
    var y2diff;
    var ydiff;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj92;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj92, 92);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_rocky2(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 92)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(-1e+06, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj92 = enigma::link_obj_instance(this, 92);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_rocky2()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj92;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_Alaska: object_locals
  {
    //Locals to instances of this object
    var col;
    var fa_center;
    var fa_middle;
    var font;
    var nx;
    
    //Scripts called by this object
    
    variant _SCR_Title_4(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj93;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj93, 93);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_Alaska(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 93)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj93 = enigma::link_obj_instance(this, 93);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_Alaska()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj93;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_water: object_locals
  {
    //Locals to instances of this object
    var bonus;
    var bw;
    var orgn;
    var vc;
    var vx;
    var vxp;
    var vy;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj94;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj94, 94);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_water(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 94)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(-1e+06, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj94 = enigma::link_obj_instance(this, 94);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_water()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj94;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_alaska: object_locals
  {
    //Locals to instances of this object
    var bh;
    var bonus;
    var bw;
    var mx2vc;
    var mx2y;
    var mxvc;
    var mxy;
    var orgn;
    var orgn2y;
    var orgn3y;
    var orgny;
    var vc;
    var vcy;
    var vx;
    var vxp;
    var vy;
    var vyp;
    var y2diff;
    var ydiff;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj95;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj95, 95);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_alaska(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 95)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(1e+08, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj95 = enigma::link_obj_instance(this, 95);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_alaska()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj95;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_elec_96: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj96;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj96, 96);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_elec_96(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 96), $iip(-1)
    {
      sprite_index = 99;
      visible = 1;
      solid = 0;
      depth.init(-20, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj96 = enigma::link_obj_instance(this, 96);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_elec_96()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj96;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_fire_shield: object_locals
  {
    //Locals to instances of this object
    var imageindex;
    var on;
    var r;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_endstep();
        variant myevent_collision_0();
        variant myevent_collision_60();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(0)) myevent_collision_0();
        if (instance_number(60)) myevent_collision_60();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj97;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj97, 97);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_fire_shield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 97)
    {
      sprite_index = 100;
      visible = 1;
      solid = 0;
      depth.init(-20, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj97 = enigma::link_obj_instance(this, 97);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_fire_shield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj97;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_fireshield: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var busted;
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_6();
        variant myevent_animationend();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj98;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj98, 98);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_fireshield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 98), $iip(-1)
    {
      sprite_index = 58;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj98 = enigma::link_obj_instance(this, 98);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_fireshield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj98;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_bubbleshield: object_locals
  {
    //Locals to instances of this object
    float $iip;
    var busted;
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_collision_6();
        variant myevent_animationend();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj99;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj99, 99);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_bubbleshield(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 99), $iip(-1)
    {
      sprite_index = 58;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj99 = enigma::link_obj_instance(this, 99);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_bubbleshield()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj99;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_bubble_shield_100: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj100;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj100, 100);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_bubble_shield_100(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 100)
    {
      sprite_index = 102;
      visible = 1;
      solid = 0;
      depth.init(-20, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj100 = enigma::link_obj_instance(this, 100);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_bubble_shield_100()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj100;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_vertfloor: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj101;
      enigma::inst_iter *ENOBJ_ITER_myobj21;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj101, 101);
      unlink_object_id_iter(ENOBJ_ITER_myobj21, 21);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_vertfloor(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 101)
    {
      sprite_index = 64;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj101 = enigma::link_obj_instance(this, 101);
      ENOBJ_ITER_myobj21 = enigma::link_obj_instance(this, 21);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_vertfloor()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj101;
      delete ENOBJ_ITER_myobj21;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_panel: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_collision_6();
        variant myevent_keypress_90();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
      void myevent_keypress()
      {
        if (keyboard_check_pressed(90)) myevent_keypress_90();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj102;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;
      enigma::inst_iter *ENOBJ_ITER_myevent_keypress;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj102, 102);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
      enigma::event_keypress->unlink(ENOBJ_ITER_myevent_keypress);
    }
    
    OBJ_panel(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 102)
    {
      sprite_index = 97;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj102 = enigma::link_obj_instance(this, 102);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      ENOBJ_ITER_myevent_keypress = enigma::event_keypress->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_panel()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj102;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
      delete ENOBJ_ITER_myevent_keypress;
    }
  };
  
  struct OBJ_fadeout: object_locals
  {
    //Locals to instances of this object
    var alpha;
    var set;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_endstep();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj103;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj103, 103);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
    }
    
    OBJ_fadeout(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 103)
    {
      sprite_index = 103;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj103 = enigma::link_obj_instance(this, 103);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_fadeout()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj103;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_plane: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj104;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj104, 104);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_plane(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 104)
    {
      sprite_index = 104;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj104 = enigma::link_obj_instance(this, 104);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_plane()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj104;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_on_ice: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj105;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj105, 105);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_on_ice(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 105)
    {
      sprite_index = 105;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj105 = enigma::link_obj_instance(this, 105);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_on_ice()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj105;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object106: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_collision_6();
        variant myevent_animationend();
    
    
    // Grouped event bases
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj106;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj106, 106);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_object106(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 106), $iip(-1)
    {
      sprite_index = 106;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj106 = enigma::link_obj_instance(this, 106);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object106()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj106;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_smoke: object_locals
  {
    //Locals to instances of this object
    float $iip;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_animationend();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj107;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_animationend;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj107, 107);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_animationend->unlink(ENOBJ_ITER_myevent_animationend);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_smoke(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 107), $iip(-1)
    {
      sprite_index = 23;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj107 = enigma::link_obj_instance(this, 107);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_animationend = enigma::event_animationend->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_smoke()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj107;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_animationend;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_icewall: object_locals
  {
    //Locals to instances of this object
    var broken;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj108;
      enigma::inst_iter *ENOBJ_ITER_myobj60;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj108, 108);
      unlink_object_id_iter(ENOBJ_ITER_myobj60, 60);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_icewall(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 108)
    {
      sprite_index = 107;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj108 = enigma::link_obj_instance(this, 108);
      ENOBJ_ITER_myobj60 = enigma::link_obj_instance(this, 60);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_icewall()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj108;
      delete ENOBJ_ITER_myobj60;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_snowflake: object_locals
  {
    //Locals to instances of this object
    var angle;
    var dist;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_4();
        variant myevent_step();
        variant myevent_endstep();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_4();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj109;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj109, 109);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_snowflake(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 109)
    {
      sprite_index = 116;
      visible = 1;
      solid = 0;
      depth.init(-20, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj109 = enigma::link_obj_instance(this, 109);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_snowflake()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj109;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_skinnyflat: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj110;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj110, 110);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_skinnyflat(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 110)
    {
      sprite_index = 111;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj110 = enigma::link_obj_instance(this, 110);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_skinnyflat()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj110;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_flat_er: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj111;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj111, 111);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_flat_er(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 111)
    {
      sprite_index = 110;
      visible = 0;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj111 = enigma::link_obj_instance(this, 111);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_flat_er()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj111;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_watersurface: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_alarm_0();
        variant myevent_endstep();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj112;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj112, 112);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_watersurface(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 112)
    {
      sprite_index = 112;
      visible = 0;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj112 = enigma::link_obj_instance(this, 112);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_watersurface()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj112;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_wlmaker: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj113;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj113, 113);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_wlmaker(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 113)
    {
      sprite_index = 45;
      visible = 0;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj113 = enigma::link_obj_instance(this, 113);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_wlmaker()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj113;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_eggopening: object_locals
  {
    //Locals to instances of this object
    var a;
    var o;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_step();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj114;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj114, 114);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_eggopening(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 114)
    {
      sprite_index = 103;
      visible = 1;
      solid = 0;
      depth.init(-100, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj114 = enigma::link_obj_instance(this, 114);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_eggopening()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj114;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_eyes: object_locals
  {
    //Locals to instances of this object
    var ch1;
    var ch2;
    var mx2x;
    var mx2xc;
    var mxx;
    var mxxc;
    var x2diff;
    var xdiff;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_step();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj115;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj115, 115);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_eyes(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 115)
    {
      sprite_index = 115;
      visible = 1;
      solid = 0;
      depth.init(10000, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj115 = enigma::link_obj_instance(this, 115);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_eyes()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj115;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_speachopening: object_locals
  {
    //Locals to instances of this object
    var enigmawrite;
    var fa_left;
    var fa_middle;
    var font;
    var gamevars;
    var writ2e;
    var writ3e;
    var writ4e;
    var writ5e;
    var writ6e;
    var writ7e;
    var wrote;
    
    //Scripts called by this object
    
    variant _SCR_opening_5(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
        variant myevent_create();
        variant myevent_step();
        variant myevent_draw();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj116;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj116, 116);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_speachopening(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 116)
    {
      sprite_index = 108;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj116 = enigma::link_obj_instance(this, 116);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_speachopening()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj116;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_snowmaker: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_7();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj117;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj117, 117);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_snowmaker(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 117)
    {
      sprite_index = 116;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj117 = enigma::link_obj_instance(this, 117);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_snowmaker()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj117;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_solidonlyafter: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj118;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj118, 118);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_solidonlyafter(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 118)
    {
      sprite_index = 42;
      visible = 0;
      solid = 0;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj118 = enigma::link_obj_instance(this, 118);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_solidonlyafter()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj118;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_solidonlywhengrinding: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj119;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj119, 119);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_solidonlywhengrinding(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 119)
    {
      sprite_index = 37;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj119 = enigma::link_obj_instance(this, 119);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_solidonlywhengrinding()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj119;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_curvetopright: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj120;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj120, 120);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_curvetopright(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 120)
    {
      sprite_index = 117;
      visible = 1;
      solid = 1;
      depth.init(1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj120 = enigma::link_obj_instance(this, 120);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_curvetopright()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj120;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_solidonlywhengrindingcurveupleft: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj121;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj121, 121);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_solidonlywhengrindingcurveupleft(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 121)
    {
      sprite_index = 39;
      visible = 0;
      solid = 1;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj121 = enigma::link_obj_instance(this, 121);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_solidonlywhengrindingcurveupleft()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj121;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_boostpad_U_L: object_locals
  {
    //Locals to instances of this object
    var ready;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_collision_6();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
      }
      void myevent_collision()
      {
        if (instance_number(6)) myevent_collision_6();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj122;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;
      enigma::inst_iter *ENOBJ_ITER_myevent_collision;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj122, 122);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
      enigma::event_collision->unlink(ENOBJ_ITER_myevent_collision);
    }
    
    OBJ_boostpad_U_L(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 122)
    {
      sprite_index = 118;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj122 = enigma::link_obj_instance(this, 122);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      ENOBJ_ITER_myevent_collision = enigma::event_collision->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_boostpad_U_L()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj122;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
      delete ENOBJ_ITER_myevent_collision;
    }
  };
  
  struct OBJ_railbottomhalf: object_locals
  {
    //Locals to instances of this object
    var n;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_7();
        variant myevent_step();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_7();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj123;
      enigma::inst_iter *ENOBJ_ITER_myobj45;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj123, 123);
      unlink_object_id_iter(ENOBJ_ITER_myobj45, 45);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_railbottomhalf(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 123)
    {
      sprite_index = 119;
      visible = 0;
      solid = 1;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj123 = enigma::link_obj_instance(this, 123);
      ENOBJ_ITER_myobj45 = enigma::link_obj_instance(this, 45);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_railbottomhalf()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj123;
      delete ENOBJ_ITER_myobj45;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_boost_pad_front: object_locals
  {
    //Locals to instances of this object
    var ready;
    
    //Scripts called by this object
    
        variant myevent_create();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj124;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj124, 124);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_boost_pad_front(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 124)
    {
      sprite_index = 118;
      visible = 1;
      solid = 0;
      depth.init(-200, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj124 = enigma::link_obj_instance(this, 124);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_boost_pad_front()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj124;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_solidonlyafter_r_d: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_step();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj125;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj125, 125);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_solidonlyafter_r_d(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 125)
    {
      sprite_index = 37;
      visible = 0;
      solid = 0;
      depth.init(10, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj125 = enigma::link_obj_instance(this, 125);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_solidonlyafter_r_d()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj125;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_top: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj126;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj126, 126);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_top(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 126)
    {
      sprite_index = 122;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj126 = enigma::link_obj_instance(this, 126);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_top()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj126;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_stem: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_create();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj127;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj127, 127);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_stem(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 127)
    {
      sprite_index = 121;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj127 = enigma::link_obj_instance(this, 127);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_stem()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj127;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_oppeningcredits: object_locals
  {
    //Locals to instances of this object
    var draw;
    
    //Scripts called by this object
    
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_alarm_2();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
        myevent_alarm_2();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj128;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj128, 128);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_oppeningcredits(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 128)
    {
      sprite_index = -1;
      visible = 1;
      solid = 0;
      depth.init(0, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj128 = enigma::link_obj_instance(this, 128);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_oppeningcredits()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj128;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
  
  struct OBJ_flatrailsolid_if_above: object_locals
  {
    //Locals to instances of this object
    
    //Scripts called by this object
    
        variant myevent_endstep();
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj129;
      enigma::inst_iter *ENOBJ_ITER_myobj11;
      enigma::inst_iter *ENOBJ_ITER_myobj0;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj129, 129);
      unlink_object_id_iter(ENOBJ_ITER_myobj11, 11);
      unlink_object_id_iter(ENOBJ_ITER_myobj0, 0);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      depth.remove();;
    }
    
    OBJ_flatrailsolid_if_above(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 129)
    {
      sprite_index = 36;
      visible = 1;
      solid = 1;
      depth.init(11, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj129 = enigma::link_obj_instance(this, 129);
      ENOBJ_ITER_myobj11 = enigma::link_obj_instance(this, 11);
      ENOBJ_ITER_myobj0 = enigma::link_obj_instance(this, 0);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_flatrailsolid_if_above()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj129;
      delete ENOBJ_ITER_myobj11;
      delete ENOBJ_ITER_myobj0;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
    }
  };
  
  struct OBJ_object130: object_locals
  {
    //Locals to instances of this object
    var col;
    var fa_center;
    var fa_middle;
    var font;
    var nx;
    
    //Scripts called by this object
    
    variant _SCR_Title_4(variant argument0 = 0, variant argument1 = 0, variant argument2 = 0, variant argument3 = 0, variant argument4 = 0);
        variant myevent_create();
        variant myevent_alarm_0();
        variant myevent_alarm_1();
        variant myevent_endstep();
        variant myevent_draw();
    
    
    // Grouped event bases
      void myevent_alarm()
      {
        myevent_alarm_0();
        myevent_alarm_1();
      }
    
    // Self-tracking
      enigma::pinstance_list_iterator ENOBJ_ITER_me;
      enigma::inst_iter *ENOBJ_ITER_myobj130;
      enigma::inst_iter *ENOBJ_ITER_myevent_create;
      enigma::inst_iter *ENOBJ_ITER_myevent_endstep;
      enigma::inst_iter *ENOBJ_ITER_myevent_step;
      enigma::inst_iter *ENOBJ_ITER_myevent_alarm;

    void unlink()
    {
      instance_iter_queue_for_destroy(ENOBJ_ITER_me); // Queue for delete while we're still valid
      enigma::unlink_main(ENOBJ_ITER_me); // Remove this instance from the non-redundant, tree-structured list.
      unlink_object_id_iter(ENOBJ_ITER_myobj130, 130);
      enigma::event_create->unlink(ENOBJ_ITER_myevent_create);
      enigma::event_endstep->unlink(ENOBJ_ITER_myevent_endstep);
      depth.remove();;
      enigma::event_step->unlink(ENOBJ_ITER_myevent_step);
      enigma::event_alarm->unlink(ENOBJ_ITER_myevent_alarm);
    }
    
    OBJ_object130(int enigma_genericconstructor_newinst_x = 0, int enigma_genericconstructor_newinst_y = 0, const int id = (enigma::maxid++)): object_locals(id, 130)
    {
      sprite_index = 4;
      visible = 1;
      solid = 0;
      depth.init(-1e+07, this);
      ENOBJ_ITER_me = enigma::link_instance(this);
      ENOBJ_ITER_myobj130 = enigma::link_obj_instance(this, 130);
      ENOBJ_ITER_myevent_create = enigma::event_create->add_inst(this);
      ENOBJ_ITER_myevent_endstep = enigma::event_endstep->add_inst(this);
      ENOBJ_ITER_myevent_step = enigma::event_step->add_inst(this);
      ENOBJ_ITER_myevent_alarm = enigma::event_alarm->add_inst(this);
      x = enigma_genericconstructor_newinst_x, y = enigma_genericconstructor_newinst_y;
      enigma::constructor(this);
      myevent_roomstart();      myevent_create();
    }
    
    ~OBJ_object130()
    {
      enigma::winstance_list_iterator_delete(ENOBJ_ITER_me);
      delete ENOBJ_ITER_myobj130;
      delete ENOBJ_ITER_myevent_create;
      delete ENOBJ_ITER_myevent_endstep;
      delete ENOBJ_ITER_myevent_step;
      delete ENOBJ_ITER_myevent_alarm;
    }
  };
}
