/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant _SCR_level_save_random(variant argument0, variant argument1, variant argument2)
{
  with(self)
  {
    
    {
      enigma::varaccess_file(int(self))= file_text_open_write(argument0);
      repeat(argument1)
      {
        file_text_write_string(enigma::varaccess_file(int(self)), object_get_name(argument2));
        file_text_writeln(enigma::varaccess_file(int(self)));
        file_text_write_string(enigma::varaccess_file(int(self)), toString(round(random(room_width))));
        file_text_writeln(enigma::varaccess_file(int(self)));
        file_text_write_string(enigma::varaccess_file(int(self)), toString(round(random(room_height))));
        file_text_writeln(enigma::varaccess_file(int(self)));
        
      }
      file_text_close(enigma::varaccess_file(int(self)));
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_level_save()
{
  with(self)
  {
    
    {
      with(argument0)
      {
        enigma::varaccess_file(int(self))= file_text_open_append(enigma::varaccess_argument1(int(other)));
        file_text_write_string(enigma::varaccess_file(int(self)), object_get_name(enigma::glaccess(int(self))-> object_index));
        file_text_write_string(enigma::varaccess_file(int(self)), toString(enigma::glaccess(int(self))-> x));
        file_text_write_string(enigma::varaccess_file(int(self)), toString(enigma::glaccess(int(self))-> y));
        file_text_close(enigma::varaccess_file(int(self)));
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_level_load(variant argument0)
{
  with(self)
  {
    
    {
      enigma::varaccess_enigmawidth(int(self))= view_wview[0] / (double) 2;
      enigma::varaccess_enigmaheight(int(self))= view_hview[0] / (double) 2;
      enigma::varaccess_temp_x(int(self))= enigma_floor(room_width / (double) enigma::varaccess_enigmawidth(int(self)))+ 2;
      enigma::varaccess_temp_y(int(self))= enigma_floor(room_height / (double) enigma::varaccess_enigmaheight(int(self)))+ 2;
      for(enigma::varaccess_xx(int(self))= 0; enigma::varaccess_xx(int(self))<= enigma::varaccess_temp_x(int(self)); enigma::varaccess_xx(int(self))+= 1)
        for(enigma::varaccess_yy(int(self))= 0; enigma::varaccess_yy(int(self))<= enigma::varaccess_temp_y(int(self)); enigma::varaccess_yy(int(self))+= 1)
      {
        enigma::varaccess_group_amount(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self)))= 0;
        enigma::varaccess_group_status(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self)))= 0;
        enigma::varaccess_group_id(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self)))= 0;
        
      }
      enigma::varaccess_object_numb(int(self))= 0;
      enigma::varaccess_temp(int(self))= 1;
      enigma::varaccess_lines(int(self))= 0;
      enigma::varaccess_file(int(self))= file_text_open_read(argument0);
      while(! file_text_eof(enigma::varaccess_file(int(self))))
      {
        file_text_readln(enigma::varaccess_file(int(self)));
        enigma::varaccess_lines(int(self))+= 1;
        
      }
      enigma::varaccess_lines(int(self))= enigma_floor(enigma::varaccess_lines(int(self))/ (double) 3);
      file_text_close(enigma::varaccess_file(int(self)));
      enigma::varaccess_file(int(self))= file_text_open_read(argument0);
      repeat(enigma::varaccess_lines(int(self)))
      {
        variable_local_set("name", file_text_read_string(enigma::varaccess_file(int(self))));
        enigma::varaccess_object(int(self))(enigma::varaccess_object_numb(int(self)))= enigma::varaccess_name(int(self));
        file_text_readln(enigma::varaccess_file(int(self)));
        enigma::varaccess_object_x(int(self))(enigma::varaccess_object_numb(int(self)))= real(file_text_read_string(enigma::varaccess_file(int(self))));
        file_text_readln(enigma::varaccess_file(int(self)));
        enigma::varaccess_object_y(int(self))(enigma::varaccess_object_numb(int(self)))= real(file_text_read_string(enigma::varaccess_file(int(self))));
        file_text_readln(enigma::varaccess_file(int(self)));
        enigma::varaccess_temp_x(int(self))= enigma_floor(enigma::varaccess_object_x(int(self))(enigma::varaccess_object_numb(int(self))) / (double) enigma::varaccess_enigmawidth(int(self)))+ 1;
        enigma::varaccess_temp_y(int(self))= enigma_floor(enigma::varaccess_object_y(int(self))(enigma::varaccess_object_numb(int(self))) / (double) enigma::varaccess_enigmaheight(int(self)))+ 1;
        if(enigma::varaccess_group_amount(int(self))(enigma::varaccess_temp_x(int(self)), enigma::varaccess_temp_y(int(self)))== 0)
        {
          enigma::varaccess_group_id(int(self))(enigma::varaccess_temp_x(int(self)), enigma::varaccess_temp_y(int(self)))= enigma::varaccess_temp(int(self));
          enigma::varaccess_temp(int(self))+= 1;
          
        }
        enigma::varaccess_group_object(int(self))(enigma::varaccess_group_id(int(self))(enigma::varaccess_temp_x(int(self)), enigma::varaccess_temp_y(int(self))), enigma::varaccess_group_amount(int(self))(enigma::varaccess_temp_x(int(self)), enigma::varaccess_temp_y(int(self))))= enigma::varaccess_object_numb(int(self));
        enigma::varaccess_group_amount(int(self))(enigma::varaccess_temp_x(int(self)), enigma::varaccess_temp_y(int(self))) += 1;
        enigma::varaccess_object_numb(int(self))+= 1;
        
      }
      file_text_close(enigma::varaccess_file(int(self)));
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_level_step()
{
  with(self)
  {
    
    {
      enigma::varaccess_temp_x(int(self))= enigma_floor((view_xview[0] + view_wview[0] / (double) 2)/ (double) enigma::varaccess_enigmawidth(int(self)))+ 1;
      enigma::varaccess_temp_y(int(self))= enigma_floor((view_yview[0] + view_hview[0] / (double) 2)/ (double) enigma::varaccess_enigmaheight(int(self)))+ 1;
      for(enigma::varaccess_xx(int(self))= enigma::varaccess_temp_x(int(self))- 1; enigma::varaccess_xx(int(self))<= enigma::varaccess_temp_x(int(self))+ 1; enigma::varaccess_xx(int(self))+= 1)
      {
        for(enigma::varaccess_yy(int(self))= enigma::varaccess_temp_y(int(self))- 1; enigma::varaccess_yy(int(self))<= enigma::varaccess_temp_y(int(self))+ 1; enigma::varaccess_yy(int(self))+= 1)
        {
          if(enigma::varaccess_group_amount(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self))) > 0)
            if(! enigma::varaccess_group_status(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self))) )
          {
            for(enigma::varaccess_i(int(self))= 0; enigma::varaccess_i(int(self))< enigma::varaccess_group_amount(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self))); enigma::varaccess_i(int(self))+= 1)
            {
              enigma::varaccess_temp(int(self))= enigma::varaccess_group_object(int(self))(enigma::varaccess_group_id(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self))), enigma::varaccess_i(int(self)));
              instance_create(enigma::varaccess_object_x(int(self))(enigma::varaccess_temp(int(self))), enigma::varaccess_object_y(int(self))(enigma::varaccess_temp(int(self))), enigma::varaccess_object(int(self))(enigma::varaccess_temp(int(self))) );
              
            }
            enigma::varaccess_group_status(int(self))(enigma::varaccess_xx(int(self)), enigma::varaccess_yy(int(self)))= 1;
            
          }
          
        }
        
      }
      instance_activate_all();
      instance_deactivate_region(enigma_max(0, view_xview[0] - enigma::varaccess_enigmawidth(int(self))/ (double) 2), enigma_max(0, view_yview[0] - enigma::varaccess_enigmaheight(int(self))/ (double) 2), enigma_min(room_width, view_wview[0] + enigma::varaccess_enigmawidth(int(self))), enigma_min(room_height, view_hview[0] + enigma::varaccess_enigmaheight(int(self))), 0, 1);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    
    {
      level_save_random(working_directory + "\\level.txt", 200, obj_ball);
      level_load(working_directory + "\\level.txt");
      show_message("working_directory"+ toString(working_directory));
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::myevent_step()
{
  enigma::propagate_locals(this);

  {
    
    {
      if(keyboard_check(vk_left))
        view_xview[0]= enigma_max(view_xview[0] - 10, 0);
      if(keyboard_check(vk_right))
        view_xview[0]= enigma_min(view_xview[0] + 10, room_width - view_wview[0] );
      if(keyboard_check(vk_up))
        view_yview[0]= enigma_max(view_yview[0] - 10, 0);
      if(keyboard_check(vk_down))
        view_yview[0]= enigma_min(view_yview[0] + 10, room_height - view_hview[0] );
      level_step();
      room_caption ="Instance Count: "+ toString(instance_count);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::_SCR_level_load(variant argument0)
{
  
  {
    enigmawidth = view_wview[0] / (double) 2;
    enigmaheight = view_hview[0] / (double) 2;
    temp_x = enigma_floor(room_width / (double) enigmawidth)+ 2;
    temp_y = enigma_floor(room_height / (double) enigmaheight)+ 2;
    for(xx = 0; xx <= temp_x; xx += 1)
      for(yy = 0; yy <= temp_y; yy += 1)
    {
      group_amount(xx, yy)= 0;
      group_status(xx, yy)= 0;
      group_id(xx, yy)= 0;
      
    }
    object_numb = 0;
    temp = 1;
    lines = 0;
    file = file_text_open_read(argument0);
    while(! file_text_eof(file))
    {
      file_text_readln(file);
      lines += 1;
      
    }
    lines = enigma_floor(lines / (double) 3);
    file_text_close(file);
    file = file_text_open_read(argument0);
    repeat(lines)
    {
      variable_local_set("name", file_text_read_string(file));
      object(object_numb)= name;
      file_text_readln(file);
      object_x(object_numb)= real(file_text_read_string(file));
      file_text_readln(file);
      object_y(object_numb)= real(file_text_read_string(file));
      file_text_readln(file);
      temp_x = enigma_floor(object_x(object_numb) / (double) enigmawidth)+ 1;
      temp_y = enigma_floor(object_y(object_numb) / (double) enigmaheight)+ 1;
      if(group_amount(temp_x, temp_y)== 0)
      {
        group_id(temp_x, temp_y)= temp;
        temp += 1;
        
      }
      group_object(group_id(temp_x, temp_y), group_amount(temp_x, temp_y))= object_numb;
      group_amount(temp_x, temp_y) += 1;
      object_numb += 1;
      
    }
    file_text_close(file);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::_SCR_level_save_random(variant argument0, variant argument1, variant argument2)
{
  
  {
    file = file_text_open_write(argument0);
    repeat(argument1)
    {
      file_text_write_string(file, object_get_name(argument2));
      file_text_writeln(file);
      file_text_write_string(file, toString(round(random(room_width))));
      file_text_writeln(file);
      file_text_write_string(file, toString(round(random(room_height))));
      file_text_writeln(file);
      
    }
    file_text_close(file);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::_SCR_level_step()
{
  
  {
    temp_x = enigma_floor((view_xview[0] + view_wview[0] / (double) 2)/ (double) enigmawidth)+ 1;
    temp_y = enigma_floor((view_yview[0] + view_hview[0] / (double) 2)/ (double) enigmaheight)+ 1;
    for(xx = temp_x - 1; xx <= temp_x + 1; xx += 1)
    {
      for(yy = temp_y - 1; yy <= temp_y + 1; yy += 1)
      {
        if(group_amount(xx, yy) > 0)
          if(! group_status(xx, yy) )
        {
          for(i = 0; i < group_amount(xx, yy); i += 1)
          {
            temp = group_object(group_id(xx, yy), i);
            instance_create(object_x(temp), object_y(temp), object(temp) );
            
          }
          group_status(xx, yy)= 1;
          
        }
        
      }
      
    }
    instance_activate_all();
    instance_deactivate_region(enigma_max(0, view_xview[0] - enigmawidth / (double) 2), enigma_max(0, view_yview[0] - enigmaheight / (double) 2), enigma_min(room_width, view_wview[0] + enigmawidth), enigma_min(room_height, view_hview[0] + enigmaheight), 0, 1);
    
  }
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
    { (variant(*)())_SCR_level_save_random, 3 },
    { (variant(*)())_SCR_level_save, 0 },
    { (variant(*)())_SCR_level_load, 1 },
    { (variant(*)())_SCR_level_step, 0 },
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
