/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant _SCR_point_collision_x(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4, variant argument5, variant argument6)
{
  var dist1, dist2, tempx, tempy, i;
  if(argument3 > argument6)
    return "false";
  i = 0;
  do
  {
    tempx = argument0 + lengthdir_x(i * argument3, argument2);
    tempy = argument1 + lengthdir_y(i * argument3, argument2);
    dist1 = point_distance(argument4, argument5, tempx, tempy);
    dist2 = point_distance(argument0, argument1, tempx, tempy);
    i = dist1 / (double) argument6;
    
  }
  until(abs(dist1 / (double) argument6 * argument3 - dist2)< 1);
  return tempx;
  ;
  
  return 0;
}

variant _SCR_point_collision_y(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4, variant argument5, variant argument6)
{
  var dist1, dist2, tempx, tempy, i;
  if(argument3 > argument6)
    return "false";
  i = 0;
  do
  {
    tempx = argument0 + lengthdir_x(i * argument3, argument2);
    tempy = argument1 + lengthdir_y(i * argument3, argument2);
    dist1 = point_distance(argument4, argument5, tempx, tempy);
    dist2 = point_distance(argument0, argument1, tempx, tempy);
    i = dist1 / (double) argument6;
    
  }
  until(abs(dist1 / (double) argument6 * argument3 - dist2)< 1);
  return tempy;
  ;
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    direction = 90;
    bullet_speed = 15;
    can_shoot = 1;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_step()
{
  enigma::propagate_locals(this);

  {
    image_single =((double) direction)/ (double) 360 * image_number;
    obj = obj_ship;
    if(instance_exists(obj))
      if(can_shoot == 1)
    {
      point_x = point_collision_x(enigma::glaccess(int(obj))-> x, enigma::glaccess(int(obj))-> y, enigma::glaccess(int(obj))-> direction, enigma::glaccess(int(obj))-> speed, x, y, bullet_speed);
      point_y = point_collision_y(enigma::glaccess(int(obj))-> x, enigma::glaccess(int(obj))-> y, enigma::glaccess(int(obj))-> direction, enigma::glaccess(int(obj))-> speed, x, y, bullet_speed);
      if(is_real(point_x)&& is_real(point_y))
      {
        dir = point_direction(x, y, point_x, point_y);
        direction = dir;
        sound_play(snd_gun);
        nnn = instance_create(x + lengthdir_x(32, direction), y + lengthdir_y(32, direction), obj_ammo);
        enigma::glaccess(int(nnn))-> direction = dir;
        enigma::glaccess(int(nnn))-> speed = bullet_speed;
        can_shoot = 0;
        
      }
      
    }
    if(! instance_exists(obj))
      can_shoot = 1;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_ship::myevent_destroy()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    instance_create(x, y, obj_explosion);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_ship::myevent_step()
{
  enigma::propagate_locals(this);

  {
    image_single =((double) direction)/ (double) 360 * image_number;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_ship::myevent_collision_3()
{
  if (!((instance_other = enigma::place_meeting_inst(x,y,3)))) return 0;
if (solid ||  enigma::glaccess(int(other))->solid) {if (enigma::place_meeting_inst(xprevious+hspeed,yprevious,3)){x=xprevious;} if (enigma::place_meeting_inst(xprevious,yprevious+vspeed,3)) { y=yprevious;}}

  {
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_ship::myevent_outsideroom()
{
  if (!((x+bbox_right < 0) || (x+bbox_left > room_width) || (y+bbox_bottom < 0) || (y+bbox_top > room_height))) return 0;

  {
    instance_destroy();
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    instance_create(screen_width / (double) 2 - 96, screen_height - 32, obj_turret);
    origin_x = screen_width;
    origin_y = screen_height / (double) 2;
    dir = point_direction(origin_x, origin_y, mouse_x, mouse_y);
    dist = point_distance(origin_x, origin_y, mouse_x, mouse_y);
    speed_factor = enigmaround(enigma_max(5, enigma_min(dist / (double) screen_width * 15, 15)));
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::myevent_mouseunknown()
{
  
  {
    if(mouse_button == mb_left)
      if(! instance_exists(obj_ship))
    {
      nnn = instance_create(origin_x, origin_y, obj_ship);
      enigma::glaccess(int(nnn))-> direction = dir;
      enigma::glaccess(int(nnn))-> speed = speed_factor;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_controller::myevent_draw()
{
  if (!(visible)) return 0;
image_index = fmod(image_index + image_speed, sprite_get_number(sprite_index));

  {
    dir = point_direction(origin_x, origin_y, mouse_x, mouse_y);
    dist = point_distance(origin_x, origin_y, mouse_x, mouse_y);
    speed_factor = enigmaround(enigma_max(5, enigma_min(dist / (double) window_get_region_width()* 15, 15)));
    point_x(1)= origin_x + lengthdir_x(2, dir - 90);
    point_y(1)= origin_y + lengthdir_y(2, dir - 90);
    point_x(2)= origin_x + lengthdir_x(2, dir + 90);
    point_y(2)= origin_y + lengthdir_y(2, dir + 90);
    point_x(3)= mouse_x + lengthdir_x(2, dir + 90);
    point_y(3)= mouse_y + lengthdir_y(2, dir + 90);
    point_x(4)= mouse_x + lengthdir_x(7, dir + 90);
    point_y(4)= mouse_y + lengthdir_y(7, dir + 90);
    point_x(5)= mouse_x + lengthdir_x(15, dir);
    point_y(5)= mouse_y + lengthdir_y(15, dir);
    point_x(6)= mouse_x + lengthdir_x(7, dir - 90);
    point_y(6)= mouse_y + lengthdir_y(7, dir - 90);
    point_x(7)= mouse_x + lengthdir_x(2, dir - 90);
    point_y(7)= mouse_y + lengthdir_y(2, dir - 90);
    pen_color = c_blue;
    draw_set_color(c_blue);
    draw_polygon_begin();
    for(i = 1; i <= 7; i += 1)
    {
      draw_polygon_vertex(point_x(i), point_y(i) );
      
    }
    draw_polygon_end();
    draw_circle(origin_x, origin_y, 10);
    font_color = c_black;
    font_name ="Arial";
    font_size = 10;
    font_align = fa_center;
    enigmadraw_text(origin_x + lengthdir_x(dist / (double) 2, dir), origin_y + lengthdir_y(dist / (double) 2, dir)+ 32, "Speed: "+ toString(speed_factor));
    font_color = c_black;
    font_name ="Arial";
    font_size = 14;
    font_align = fa_left;
    enigmadraw_text(8, 8, "Click to fire a missile at the speed shown");
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_explosion::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    sound_play(snd_explosion);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_explosion::myevent_animationend()
{
  { const bool r = ($iip < image_index); $iip = image_index; if (r) return 0; }

  {
    instance_destroy();
    
  }
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
    { (variant(*)())_SCR_point_collision_x, 7 },
    { NULL, -1 },
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
