/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant enigma::OBJ_obj_smoke::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    argument_relative = 0;
    action_set_motion(enigmarandom(360), 1);
    
  }
  
  {
    argument_relative = 0;
    action_set_friction(0.05);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_smoke::myevent_animationend()
{
  { const bool r = ($iip < image_index); $iip = image_index; if (r) return 0; }
action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    if(enigma::varaccess_enigmaauto(int(global))== 1 && instance_exists(obj_block))
    {
      direction = point_direction(x, y, enigma::glaccess(int(instance_nearest(x, y, obj_block)))-> x, enigma::glaccess(int(instance_nearest(x, y, obj_block)))-> y);
      
    }
    else
    {
      direction = 0;
      
    }
    speed = 5;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_destroy()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    show_message("destroy");
    
  }
  
  {
    argument_relative = 1;
    action_create_object(obj_bomb, 10, 0);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_step()
{
  enigma::propagate_locals(this);

  {
    argument_relative = 1;
    action_create_object(obj_smoke, 0, 0);
    
  }
  
  {
    argument_relative = 1;
    action_create_object(obj_smoke, 0, 0);
    
  }
  
  {
    argument_relative = 1;
    action_create_object(obj_smoke, 0, 0);
    
  }
  
  {
    image_index =((double) direction)/ (double) 5;
    if(x > room_width + 100)
    {
      x = room_width * 2;
      instance_destroy();
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_collision_3()
{
  if (!((instance_other = enigma::place_meeting_inst(x,y,3)))) return 0;
if (solid ||  enigma::glaccess(int(other))->solid) {if (enigma::place_meeting_inst(xprevious+hspeed,yprevious,3)){x=xprevious;} if (enigma::place_meeting_inst(xprevious,yprevious+vspeed,3)) { y=yprevious;}}
action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_keyboard_17()
{
  action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_keyboard_37()
{
  
  {
    if(enigma::varaccess_enigmaauto(int(global))== 0)
    {
      direction += 5;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_rocket::myevent_keyboard_39()
{
  
  {
    if(enigma::varaccess_enigmaauto(int(global))== 0)
    {
      direction -= 5;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_block::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(instance_exists(obj_bomb))
    {
      if(distance_to_point(enigma::glaccess(int(obj_bomb))-> x, enigma::glaccess(int(obj_bomb))-> y)< 100)
      {
        show_message("X:"+ toString(x)+ "y:"+ toString(y)+ " distance:"+ toString(distance_to_point(enigma::glaccess(int(obj_bomb))-> x, enigma::glaccess(int(obj_bomb))-> y)));
        depth =- 1;
        sprite_index = sprite1;
        move_towards_point(enigma::glaccess(int(obj_bomb))-> x, enigma::glaccess(int(obj_bomb))-> y, - 20);
        friction = 0.7;
        gravity_direction = 270;
        gravity = 2;
        
      }
      
    }
    
  }
  
  {
    if(y > room_height)
    {
      instance_destroy();
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_block::myevent_keypress_13()
{
  
  {
    depth =- 1;
    sprite_index = sprite1;
    move_towards_point(x + enigmarandom(3)- enigmarandom(2), y + enigmarandom(2)- enigmarandom(3), - 20);
    friction = 0.5;
    gravity_direction = 270;
    gravity = 2;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_bomb::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    argument_relative = 0;
    action_set_alarm(10, 0);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_bomb::myevent_alarm_0()
{
  { if ((alarm[0] == -1) or (alarm[0]--)) return 0; }

  {
    show_message("actual x:"+ toString(x)+ " actual y:"+ toString(y));
    
  }
  action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_wall_create::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    createx = room_width - 16;
    done_createx = 0;
    createy = 0;
    done_createy = 1;
    alarm[0]= 15;
    can_create = 0;
    wallthickness = 10;
    wallthickness += 1;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_wall_create::myevent_destroy()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    argument_relative = 1;
    action_create_object(obj_wall_create, 0, 0);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_wall_create::myevent_alarm_0()
{
  { if ((alarm[0] == -1) or (alarm[0]--)) return 0; }

  {
    can_create = 1;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_wall_create::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(can_create == 1)
    {
      if(createx > room_width - 16 * wallthickness && createy < room_height && createx < room_width)
      {
        instance_create(createx, createy, obj_block);
        
      }
      if(done_createy == 1)
      {
        if(createy < room_height)
        {
          createy += 16;
          
        }
        else
        {
          done_createy = 0;
          done_createx = 1;
          
        }
        
      }
      if(done_createx == 1)
      {
        createy = 0;
        if(createx > room_width - 16 * wallthickness && createx < room_width)
        {
          createx -= 16;
          done_createx = 0;
          done_createy = 1;
          
        }
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_wall_create::myevent_keypress_13()
{
  action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  action_show_info();
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_keyboard_16()
{
  
  {
    if(instance_exists(obj_rocket)== 0)
    {
      enigma::varaccess_enigmaauto(int(global))= 1;
      instance_create(x + 56, y + 15, obj_rocket);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_keyboard_32()
{
  
  {
    if(instance_exists(obj_rocket)== 0)
    {
      enigma::varaccess_enigmaauto(int(global))= 0;
      instance_create(x + 56, y + 15, obj_rocket);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_keyboard_38()
{
  
  {
    if(y > 0)
    {
      y -= 3;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_turret::myevent_keyboard_40()
{
  
  {
    if(y < room_height - sprite_height)
    {
      y += 3;
      
    }
    
  }
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
