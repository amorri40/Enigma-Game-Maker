/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant _SCR_physics_system_init()
{
  
  {
    enigma::varaccess_object_number(int(global))= 0;
    enigma::varaccess_object(int(global))(0)= 0;
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_init()
{
  with(self)
  {
    
    {
      enigma::varaccess_object(int(global))(enigma::varaccess_object_number(int(global)))= enigma::glaccess(int(self))-> id;
      enigma::varaccess_object_number(int(global))+= 1;
      enigma::varaccess_strength(int(self))= 0.9;
      enigma::varaccess_point_numb(int(self))= 0;
      enigma::varaccess_joint_numb(int(self))= 0;
      enigma::varaccess_sprite_numb(int(self))= 0;
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_destroy()
{
  with(self)
  {
    
    {
      for(enigma::varaccess_i(int(self))= 0; enigma::varaccess_i(int(self))< enigma::varaccess_sprite_numb(int(self)); enigma::varaccess_i(int(self))+= 1)
        with(enigma::varaccess_sprite(int(self))(enigma::varaccess_i(int(self))) )
          instance_destroy();
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_import(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  with(self)
  {
    
    {
      var i, image, transparent, file, enigmawidth, enigmaheight, width2, height2;
      file = file_text_open_read(argument0);
      width2 = real(file_text_read_string(file));
      file_text_readln(file);
      height2 = real(file_text_read_string(file));
      file_text_readln(file);
      enigma::varaccess_point_numb(int(self))= real(file_text_read_string(file));
      file_text_readln(file);
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        enigma::varaccess_point_x(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_point_y(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_point_stationary(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_point_radius(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_point_friction(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        
      }
      enigma::varaccess_joint_numb(int(self))= real(file_text_read_string(file));
      file_text_readln(file);
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        enigma::varaccess_joint_point(int(self))(i, 0)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_joint_point(int(self))(i, 1)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_joint_min(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_joint_max(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_joint_dist(int(self))(i)= point_distance(enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) );
        
      }
      enigma::varaccess_sprite_numb(int(self))= real(file_text_read_string(file));
      file_text_readln(file);
      for(i = 0; i < enigma::varaccess_sprite_numb(int(self)); i += 1)
      {
        enigma::varaccess_sprite_point(int(self))(i, 0)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_sprite_point(int(self))(i, 1)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::varaccess_sprite_solid(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        if(enigma::varaccess_sprite_solid(int(self))(i) )
          enigma::varaccess_sprite(int(self))(i)= instance_create(0, 0, obj_solid);
        else enigma::varaccess_sprite(int(self))(i)= instance_create(0, 0, obj_sprite);
        enigma::varaccess_sprite_image(int(self))(i)= file_text_read_string(file);
        file_text_readln(file);
        enigma::varaccess_sprite_transparent(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        enigma::glaccess(int(enigma::varaccess_sprite(int(self))(i) ))-> sprite_index = sprite_add(working_directory + "\\"+ enigma::varaccess_sprite_image(int(self))(i), 1, 1, enigma::varaccess_sprite_transparent(int(self))(i), 0, 0, 0, 0);
        enigmawidth = enigma::varaccess_sprite_width(int(enigma::varaccess_sprite(int(self))(i) ));
        enigmaheight = enigma::varaccess_sprite_height(int(enigma::varaccess_sprite(int(self))(i) ));
        sprite_set_offset(enigma::glaccess(int(enigma::varaccess_sprite(int(self))(i) ))-> sprite_index, enigmawidth / (double) 2, enigmaheight / (double) 2);
        enigma::varaccess_sprite_offset(int(self))(i)= real(file_text_read_string(file));
        file_text_readln(file);
        
      }
      file_text_close(file);
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        if(argument1 == 2)
          enigma::varaccess_point_x(int(self))(i) -= width2 / (double) 2;
        if(argument1 == 3)
          enigma::varaccess_point_x(int(self))(i) -= width2;
        if(argument2 == 2)
          enigma::varaccess_point_y(int(self))(i) -= height2 / (double) 2;
        if(argument2 == 3)
          enigma::varaccess_point_y(int(self))(i) -= height2;
        enigma::varaccess_point_x(int(self))(i) += argument3;
        enigma::varaccess_point_y(int(self))(i) += argument4;
        
      }
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        enigma::varaccess_point_x_prev(int(self))(i)= enigma::varaccess_point_x(int(self))(i);
        enigma::varaccess_point_y_prev(int(self))(i)= enigma::varaccess_point_y(int(self))(i);
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_export()
{
  with(self)
  {
    
    {
      var file, i, max_x, max_y, min_x, min_y, enigmawidth, enigmaheight;
      max_x = 0;
      max_y = 0;
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        max_x = enigma_max(enigma::varaccess_point_x(int(self))(i), max_x);
        max_y = enigma_max(enigma::varaccess_point_y(int(self))(i), max_y);
        
      }
      min_x = max_x;
      min_y = max_y;
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        min_x = enigma_min(enigma::varaccess_point_x(int(self))(i), min_x);
        min_y = enigma_min(enigma::varaccess_point_y(int(self))(i), min_y);
        
      }
      enigmawidth = max_x - min_x;
      enigmaheight = max_y - min_y;
      file = file_text_open_write(argument0);
      file_text_write_string(file, toString(enigmawidth));
      file_text_writeln(file);
      file_text_write_string(file, toString(enigmaheight));
      file_text_writeln(file);
      file_text_write_string(file, toString(enigma::varaccess_point_numb(int(self))));
      file_text_writeln(file);
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        file_text_write_string(file, toString(enigma::varaccess_point_x(int(self))(i) - min_x));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_point_y(int(self))(i) - min_y));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_point_stationary(int(self))(i) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_point_radius(int(self))(i) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_point_friction(int(self))(i) ));
        file_text_writeln(file);
        
      }
      file_text_write_string(file, toString(enigma::varaccess_joint_numb(int(self))));
      file_text_writeln(file);
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        file_text_write_string(file, toString(enigma::varaccess_joint_point(int(self))(i, 0) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_joint_point(int(self))(i, 1) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_joint_min(int(self))(i) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_joint_max(int(self))(i) ));
        file_text_writeln(file);
        
      }
      file_text_write_string(file, toString(enigma::varaccess_sprite_numb(int(self))));
      file_text_writeln(file);
      for(i = 0; i < enigma::varaccess_sprite_numb(int(self)); i += 1)
      {
        file_text_write_string(file, toString(enigma::varaccess_sprite_point(int(self))(i, 0) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_sprite_point(int(self))(i, 1) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_sprite_solid(int(self))(i) ));
        file_text_writeln(file);
        file_text_write_string(file, enigma::varaccess_sprite_image(int(self))(i) );
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_sprite_transparent(int(self))(i) ));
        file_text_writeln(file);
        file_text_write_string(file, toString(enigma::varaccess_sprite_offset(int(self))(i) ));
        file_text_writeln(file);
        
      }
      file_text_close(file);
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_step()
{
  with(self)
  {
    
    {
      var i, ii, iii, x1, y1, x2, y2, xx, yy, lx, ly, temp_x, temp_y, numb, range, collision, temp, dist, diff, dir;
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        if(! enigma::varaccess_point_stationary(int(self))(i) )
        {
          temp_x = enigma::varaccess_point_x(int(self))(i);
          temp_y = enigma::varaccess_point_y(int(self))(i);
          enigma::varaccess_point_x(int(self))(i)= temp_x * 2 - enigma::varaccess_point_x_prev(int(self))(i);
          enigma::varaccess_point_y(int(self))(i)= temp_y * 2 - enigma::varaccess_point_y_prev(int(self))(i);
          enigma::varaccess_point_x_prev(int(self))(i)= temp_x;
          enigma::varaccess_point_y_prev(int(self))(i)= temp_y;
          
        }
        
      }
      repeat(5)
      {
        for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
        {
          dist = point_distance(enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) );
          if((dist > enigma::varaccess_joint_dist(int(self))(i) + enigma::varaccess_joint_max(int(self))(i) )|| (dist < enigma::varaccess_joint_dist(int(self))(i) - enigma::varaccess_joint_min(int(self))(i) ))
          {
            temp = dist;
            if(temp > enigma::varaccess_joint_dist(int(self))(i) + enigma::varaccess_joint_max(int(self))(i) )
              dist =((dist - (enigma::varaccess_joint_dist(int(self))(i) + enigma::varaccess_joint_max(int(self))(i) ))/ (double) 2)* enigma::varaccess_strength(int(self));
            if(temp < enigma::varaccess_joint_dist(int(self))(i) - enigma::varaccess_joint_min(int(self))(i) )
              dist =((dist - (enigma::varaccess_joint_dist(int(self))(i) - enigma::varaccess_joint_min(int(self))(i) ))/ (double) 2)* enigma::varaccess_strength(int(self));
            dir = point_direction(enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) );
            lx = lengthdir_x(dist, dir);
            ly = lengthdir_y(dist, dir);
            if(! enigma::varaccess_point_stationary(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)) )
            {
              enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)) += lx;
              enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)) += ly;
              
            }
            if(! enigma::varaccess_point_stationary(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) )
            {
              enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) -= lx;
              enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) -= ly;
              
            }
            
          }
          else
          {
            dist =((dist - enigma::varaccess_joint_dist(int(self))(i) )/ (double) 2)* enigma::varaccess_strength(int(self))* 0.05;
            dir = point_direction(enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) );
            lx = lengthdir_x(dist, dir);
            ly = lengthdir_y(dist, dir);
            if(! enigma::varaccess_point_stationary(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)) )
            {
              enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)) += lx;
              enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)) += ly;
              
            }
            if(! enigma::varaccess_point_stationary(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) )
            {
              enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) -= lx;
              enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) -= ly;
              
            }
            
          }
          
        }
        
      }
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        enigma::varaccess_point_collision(int(self))(i)= 0;
        if(! enigma::varaccess_point_stationary(int(self))(i) )
          if(collision_circle(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i), enigma::varaccess_point_radius(int(self))(i), obj_solid, 1, 0))
        {
          enigma::varaccess_point_collision(int(self))(i)= 1;
          lx = enigma::varaccess_point_x(int(self))(i) - enigma::varaccess_point_x_prev(int(self))(i);
          ly = enigma::varaccess_point_y(int(self))(i) - enigma::varaccess_point_y_prev(int(self))(i);
          temp = enigma_max(abs(lx), abs(ly));
          lx /= temp;
          ly /= temp;
          temp_x = enigma::varaccess_point_x(int(self))(i);
          temp_y = enigma::varaccess_point_y(int(self))(i);
          dist = point_distance(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i), enigma::varaccess_point_x_prev(int(self))(i), enigma::varaccess_point_y_prev(int(self))(i) );
          if(lx != 0 || ly != 0)
            while(collision_point(temp_x, temp_y, obj_solid, 1, 0))
          {
            temp_x -= lx;
            temp_y -= ly;
            if(sqr(enigma::varaccess_point_x(int(self))(i) - temp_x)+ sqr(enigma::varaccess_point_y(int(self))(i) - temp_y)> sqr(dist)+ 10)
            {
              temp_x = enigma::varaccess_point_x_prev(int(self))(i);
              temp_y = enigma::varaccess_point_y_prev(int(self))(i);
              break;
              
            }
            
          }
          numb = 0;
          range = enigma::varaccess_point_radius(int(self))(i) + 10;
          for(ii =- range; ii < range; ii += 1)
          {
            collision = sign(collision_point(temp_x + ii, temp_y, obj_solid, 1, 0));
            for(iii = 0; iii < 10; iii += 1)
              if(sign(collision_point(temp_x + ii, temp_y + iii, obj_solid, 1, 0))==- collision)
            {
              xx(numb)= temp_x + ii;
              yy(numb)= temp_y + iii - (collision == 1);
              numb += 1;
              break;
              
            }
            for(iii = 0; iii < range / (double) 2; iii += 1)
              if(sign(collision_point(temp_x + ii, temp_y - iii, obj_solid, 1, 0))==- collision)
            {
              xx(numb)= temp_x + ii;
              yy(numb)= temp_y - iii + (collision == 1);
              numb += 1;
              break;
              
            }
            collision = sign(collision_point(temp_x, temp_y + ii, obj_solid, 1, 0));
            for(iii = 0; iii < range / (double) 2; iii += 1)
              if(sign(collision_point(temp_x + iii, temp_y + ii, obj_solid, 1, 0))==- collision)
            {
              xx(numb)= temp_x + iii - (collision == 1);
              yy(numb)= temp_y + ii;
              numb += 1;
              break;
              
            }
            for(iii = 0; iii < range / (double) 2; iii += 1)
              if(sign(collision_point(temp_x - iii, temp_y + ii, obj_solid, 1, 0))==- collision)
            {
              xx(numb)= temp_x - iii + (collision == 1);
              yy(numb)= temp_y + ii;
              numb += 1;
              break;
              
            }
            
          }
          temp(0)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(0) += sqr(xx(ii) );
          temp(1)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(1) += xx(ii);
          lx = numb * temp(0) - sqr(temp(1) );
          temp(0)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(0) += sqr(yy(ii) );
          temp(1)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(1) += yy(ii);
          ly = numb * temp(0) - sqr(temp(1) );
          temp(0)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(0) += xx(ii) * yy(ii);
          temp(1)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(1) += xx(ii);
          temp(2)= 0;
          for(ii = 0; ii < numb; ii += 1)
            temp(2) += yy(ii);
          enigma::varaccess_tempdist(int(self))= numb * temp(0) - temp(1) * temp(2);
          if(abs(lx)> abs(ly))
            ly = enigma::varaccess_tempdist(int(self));
          else lx = enigma::varaccess_tempdist(int(self));
          dir = point_direction(0, 0, lx, ly);
          diff = physics_angle(dir, point_direction(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i), enigma::varaccess_point_x_prev(int(self))(i), enigma::varaccess_point_y_prev(int(self))(i) ));
          dist = point_distance(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i), enigma::varaccess_point_x_prev(int(self))(i), enigma::varaccess_point_y_prev(int(self))(i) );
          lx = lengthdir_x(1, dir + sign(diff)* 90);
          ly = lengthdir_y(1, dir + sign(diff)* 90);
          temp_x = enigma::varaccess_point_x(int(self))(i);
          temp_y = enigma::varaccess_point_y(int(self))(i);
          temp = 0;
          while(collision_circle(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i), enigma::varaccess_point_radius(int(self))(i), obj_solid, 1, 0))
          {
            enigma::varaccess_point_x(int(self))(i) += lx;
            enigma::varaccess_point_y(int(self))(i) += ly;
            if(sqr(enigma::varaccess_point_x(int(self))(i) - temp_x)+ sqr(enigma::varaccess_point_y(int(self))(i) - temp_y)> sqr(dist)+ 10)
            {
              if(temp)
              {
                enigma::varaccess_point_x(int(self))(i)= enigma::varaccess_point_x_prev(int(self))(i);
                enigma::varaccess_point_y(int(self))(i)= enigma::varaccess_point_y_prev(int(self))(i);
                break;
                
              }
              lx =- lx;
              ly =- ly;
              enigma::varaccess_point_x(int(self))(i)= temp_x;
              enigma::varaccess_point_y(int(self))(i)= temp_y;
              temp = 1;
              
            }
            
          }
          lx = lengthdir_x(1, dir - diff);
          ly = lengthdir_y(1, dir - diff);
          enigma::varaccess_point_x_prev(int(self))(i)= enigma::varaccess_point_x(int(self))(i) + lx * dist;
          enigma::varaccess_point_y_prev(int(self))(i)= enigma::varaccess_point_y(int(self))(i) + ly * dist;
          
        }
        
      }
      for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        if(enigma::varaccess_point_collision(int(self))(i) )
        {
          lx = enigma::varaccess_point_x(int(self))(i) - enigma::varaccess_point_x_prev(int(self))(i);
          ly = enigma::varaccess_point_y(int(self))(i) - enigma::varaccess_point_y_prev(int(self))(i);
          enigma::varaccess_point_x_prev(int(self))(i)= enigma::varaccess_point_x(int(self))(i) - lx * (1 - enigma::varaccess_point_friction(int(self))(i) );
          enigma::varaccess_point_y_prev(int(self))(i)= enigma::varaccess_point_y(int(self))(i) - ly * (1 - enigma::varaccess_point_friction(int(self))(i) );
          
        }
        
      }
      for(i = 0; i < enigma::varaccess_sprite_numb(int(self)); i += 1)
      {
        x1 = enigma::varaccess_point_x(int(self))(enigma::varaccess_sprite_point(int(self))(i, 0));
        y1 = enigma::varaccess_point_y(int(self))(enigma::varaccess_sprite_point(int(self))(i, 0));
        x2 = enigma::varaccess_point_x(int(self))(enigma::varaccess_sprite_point(int(self))(i, 1));
        y2 = enigma::varaccess_point_y(int(self))(enigma::varaccess_sprite_point(int(self))(i, 1));
        enigma::glaccess(int(enigma::varaccess_sprite(int(self))(i) ))-> x =(x1 + x2)/ (double) 2;
        enigma::glaccess(int(enigma::varaccess_sprite(int(self))(i) ))-> y =(y1 + y2)/ (double) 2;
        enigma::glaccess(int(enigma::varaccess_sprite(int(self))(i) ))-> image_angle = point_direction(x1, y1, x2, y2)+ enigma::varaccess_sprite_offset(int(self))(i);
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_draw(variant argument0, variant argument1, variant argument2)
{
  with(self)
  {
    
    {
      var i;
      draw_set_color(c_black);
      if(argument0)
        for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
          draw_circle(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i), enigma_max(3, enigma::varaccess_point_radius(int(self))(i) ), 0);
      if(argument1)
        for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
          draw_line(enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) );
      draw_set_halign(enigma::varaccess_fa_center(int(self)));
      draw_set_color(c_red);
      if(argument2)
        for(i = 0; i < enigma::varaccess_point_numb(int(self)); i += 1)
          draw_text(enigma::varaccess_point_x(int(self))(i), enigma::varaccess_point_y(int(self))(i) - 20, toString(i));
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_settings(variant argument0)
{
  with(self)
  {
    
    {
      enigma::varaccess_strength(int(self))= argument0;
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_motion(variant argument0, variant argument1, variant argument2, variant argument3)
{
  with(self)
  {
    
    {
      var i;
      for(i = argument0; i < argument0 + argument1; i += 1)
      {
        enigma::varaccess_point_x_prev(int(self))(i) -= argument2;
        enigma::varaccess_point_y_prev(int(self))(i) -= argument3;
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_position()
{
  with(self)
  {
    
    {
      var i;
      enigma::varaccess_point_x(int(self))(argument0)= argument1;
      enigma::varaccess_point_y(int(self))(argument0)= argument2;
      enigma::varaccess_point_x_prev(int(self))(argument0)= argument1;
      enigma::varaccess_point_y_prev(int(self))(argument0)= argument2;
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        if((enigma::varaccess_joint_point(int(self))(i, 0)== argument0)|| (enigma::varaccess_joint_point(int(self))(i, 1)== argument0))
          enigma::varaccess_joint_dist(int(self))(i)= point_distance(enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 0)), enigma::varaccess_point_x(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)), enigma::varaccess_point_y(int(self))(enigma::varaccess_joint_point(int(self))(i, 1)) );
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_point_add()
{
  with(self)
  {
    
    {
      enigma::varaccess_point_x(int(self))(enigma::varaccess_point_numb(int(self)))= argument0;
      enigma::varaccess_point_y(int(self))(enigma::varaccess_point_numb(int(self)))= argument1;
      enigma::varaccess_point_x_prev(int(self))(enigma::varaccess_point_numb(int(self)))= argument0;
      enigma::varaccess_point_y_prev(int(self))(enigma::varaccess_point_numb(int(self)))= argument1;
      enigma::varaccess_point_radius(int(self))(enigma::varaccess_point_numb(int(self)))= argument2;
      enigma::varaccess_point_stationary(int(self))(enigma::varaccess_point_numb(int(self)))= argument3;
      enigma::varaccess_point_friction(int(self))(enigma::varaccess_point_numb(int(self)))= argument4;
      enigma::varaccess_point_numb(int(self))+= 1;
      return enigma::varaccess_point_numb(int(self))- 1;
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_point_remove()
{
  with(self)
  {
    
    {
      var i, ii;
      if(argument0 >= enigma::varaccess_point_numb(int(self)))
        exit;
      enigma::varaccess_point_numb(int(self))-= 1;
      for(i = argument0; i < enigma::varaccess_point_numb(int(self)); i += 1)
      {
        enigma::varaccess_point_x(int(self))(i)= enigma::varaccess_point_x(int(self))(i + 1);
        enigma::varaccess_point_y(int(self))(i)= enigma::varaccess_point_y(int(self))(i + 1);
        enigma::varaccess_point_x_prev(int(self))(i)= enigma::varaccess_point_x_prev(int(self))(i + 1);
        enigma::varaccess_point_y_prev(int(self))(i)= enigma::varaccess_point_y_prev(int(self))(i + 1);
        enigma::varaccess_point_stationary(int(self))(i)= enigma::varaccess_point_stationary(int(self))(i + 1);
        enigma::varaccess_point_radius(int(self))(i)= enigma::varaccess_point_radius(int(self))(i + 1);
        enigma::varaccess_point_friction(int(self))(i)= enigma::varaccess_point_friction(int(self))(i + 1);
        
      }
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        if((enigma::varaccess_joint_point(int(self))(i, 0)== argument0)|| (enigma::varaccess_joint_point(int(self))(i, 1)== argument0))
        {
          enigma::varaccess_joint_numb(int(self))-= 1;
          for(ii = i; ii < enigma::varaccess_joint_numb(int(self)); ii += 1)
          {
            enigma::varaccess_joint_point(int(self))(ii, 0)= enigma::varaccess_joint_point(int(self))(ii + 1, 0);
            enigma::varaccess_joint_point(int(self))(ii, 1)= enigma::varaccess_joint_point(int(self))(ii + 1, 1);
            enigma::varaccess_joint_min(int(self))(ii)= enigma::varaccess_joint_min(int(self))(ii + 1);
            enigma::varaccess_joint_max(int(self))(ii)= enigma::varaccess_joint_max(int(self))(ii + 1);
            enigma::varaccess_joint_dist(int(self))(ii)= enigma::varaccess_joint_dist(int(self))(ii + 1);
            
          }
          
        }
        
      }
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        if(enigma::varaccess_joint_point(int(self))(i, 0) > argument0)
          enigma::varaccess_joint_point(int(self))(i, 0) -= 1;
        if(enigma::varaccess_joint_point(int(self))(i, 1) > argument0)
          enigma::varaccess_joint_point(int(self))(i, 1) -= 1;
        
      }
      for(i = 0; i < enigma::varaccess_sprite_numb(int(self)); i += 1)
      {
        if((enigma::varaccess_sprite_point(int(self))(i, 0)== argument0)|| (enigma::varaccess_sprite_point(int(self))(i, 1)== argument0))
        {
          with(enigma::varaccess_sprite(int(self))(i) )
            instance_destroy();
          enigma::varaccess_sprite_numb(int(self))-= 1;
          for(ii = i; ii < enigma::varaccess_sprite_numb(int(self)); ii += 1)
          {
            enigma::varaccess_sprite_point(int(self))(ii, 0)= enigma::varaccess_sprite_point(int(self))(ii + 1, 0);
            enigma::varaccess_sprite_point(int(self))(ii, 1)= enigma::varaccess_sprite_point(int(self))(ii + 1, 1);
            enigma::varaccess_sprite(int(self))(ii)= enigma::varaccess_sprite(int(self))(ii + 1);
            enigma::varaccess_sprite_offset(int(self))(ii)= enigma::varaccess_sprite_offset(int(self))(ii + 1);
            enigma::varaccess_sprite_image(int(self))(ii)= enigma::varaccess_sprite_image(int(self))(ii + 1);
            enigma::varaccess_sprite_transparent(int(self))(ii)= enigma::varaccess_sprite_transparent(int(self))(ii + 1);
            
          }
          
        }
        
      }
      for(i = 0; i < enigma::varaccess_sprite_numb(int(self)); i += 1)
      {
        if(enigma::varaccess_sprite_point(int(self))(i, 0) > argument0)
          enigma::varaccess_sprite_point(int(self))(i, 0) -= 1;
        if(enigma::varaccess_sprite_point(int(self))(i, 1) > argument0)
          enigma::varaccess_sprite_point(int(self))(i, 1) -= 1;
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_joint_add()
{
  with(self)
  {
    
    {
      var i, check;
      check = 1;
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        if((enigma::varaccess_joint_point(int(self))(i, 0)== argument0)&& (enigma::varaccess_joint_point(int(self))(i, 1)== argument1))
          check = 0;
        if((enigma::varaccess_joint_point(int(self))(i, 0)== argument1)&& (enigma::varaccess_joint_point(int(self))(i, 1)== argument0))
          check = 0;
        
      }
      if(check)
      {
        enigma::varaccess_joint_point(int(self))(enigma::varaccess_joint_numb(int(self)), 0)= argument0;
        enigma::varaccess_joint_point(int(self))(enigma::varaccess_joint_numb(int(self)), 1)= argument1;
        enigma::varaccess_joint_min(int(self))(enigma::varaccess_joint_numb(int(self)))= argument2;
        enigma::varaccess_joint_max(int(self))(enigma::varaccess_joint_numb(int(self)))= argument3;
        enigma::varaccess_joint_dist(int(self))(enigma::varaccess_joint_numb(int(self)))= point_distance(enigma::varaccess_point_x(int(self))(argument0), enigma::varaccess_point_y(int(self))(argument0), enigma::varaccess_point_x(int(self))(argument1), enigma::varaccess_point_y(int(self))(argument1) );
        enigma::varaccess_joint_numb(int(self))+= 1;
        return enigma::varaccess_joint_numb(int(self))- 1;
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_joint_remove()
{
  with(self)
  {
    
    {
      var i, ii, check;
      for(i = 0; i < enigma::varaccess_joint_numb(int(self)); i += 1)
      {
        check = 0;
        if((enigma::varaccess_joint_point(int(self))(i, 0)== argument0)&& (enigma::varaccess_joint_point(int(self))(i, 1)== argument1))
          check = 1;
        if((enigma::varaccess_joint_point(int(self))(i, 0)== argument1)&& (enigma::varaccess_joint_point(int(self))(i, 1)== argument0))
          check = 1;
        if(check)
        {
          enigma::varaccess_joint_numb(int(self))-= 1;
          for(ii = i; ii < enigma::varaccess_joint_numb(int(self)); ii += 1)
          {
            enigma::varaccess_joint_point(int(self))(ii, 0)= enigma::varaccess_joint_point(int(self))(ii + 1, 0);
            enigma::varaccess_joint_point(int(self))(ii, 1)= enigma::varaccess_joint_point(int(self))(ii + 1, 1);
            enigma::varaccess_joint_min(int(self))(ii)= enigma::varaccess_joint_min(int(self))(ii + 1);
            enigma::varaccess_joint_max(int(self))(ii)= enigma::varaccess_joint_max(int(self))(ii + 1);
            enigma::varaccess_joint_dist(int(self))(ii)= enigma::varaccess_joint_dist(int(self))(ii + 1);
            
          }
          
        }
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_sprite_add()
{
  with(self)
  {
    
    {
      var enigmawidth, enigmaheight;
      enigma::varaccess_sprite_point(int(self))(enigma::varaccess_sprite_numb(int(self)), 0)= argument0;
      enigma::varaccess_sprite_point(int(self))(enigma::varaccess_sprite_numb(int(self)), 1)= argument1;
      enigma::varaccess_sprite_solid(int(self))(enigma::varaccess_sprite_numb(int(self)))= argument2;
      enigma::varaccess_sprite_image(int(self))(enigma::varaccess_sprite_numb(int(self)))= argument3;
      enigma::varaccess_sprite_transparent(int(self))(enigma::varaccess_sprite_numb(int(self)))= argument4;
      enigma::varaccess_sprite(int(self))(enigma::varaccess_sprite_numb(int(self)))= instance_create(0, 0, obj_sprite);
      enigma::glaccess(int(enigma::varaccess_sprite(int(self))(enigma::varaccess_sprite_numb(int(self))) ))-> sprite_index = sprite_add(working_directory + "\\"+ argument3, 1, 1, argument4, 0, 0, 0, 0);
      enigmawidth = enigma::varaccess_sprite_width(int(enigma::varaccess_sprite(int(self))(enigma::varaccess_sprite_numb(int(self))) ));
      enigmaheight = enigma::varaccess_sprite_height(int(enigma::varaccess_sprite(int(self))(enigma::varaccess_sprite_numb(int(self))) ));
      sprite_set_offset(enigma::glaccess(int(enigma::varaccess_sprite(int(self))(enigma::varaccess_sprite_numb(int(self))) ))-> sprite_index, enigmawidth / (double) 2, enigmaheight / (double) 2);
      enigma::varaccess_sprite_offset(int(self))(enigma::varaccess_sprite_numb(int(self)))= argument5;
      enigma::varaccess_sprite_numb(int(self))+= 1;
      return enigma::varaccess_sprite_numb(int(self))- 1;
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_sprite_remove()
{
  with(self)
  {
    
    {
      var i;
      with(enigma::varaccess_sprite(int(self))(argument0) )
        instance_destroy();
      enigma::varaccess_sprite_numb(int(self))-= 1;
      for(i = argument0; i < enigma::varaccess_sprite_numb(int(self)); i += 1)
      {
        enigma::varaccess_sprite_point(int(self))(i, 0)= enigma::varaccess_sprite_point(int(self))(i + 1, 0);
        enigma::varaccess_sprite_point(int(self))(i, 1)= enigma::varaccess_sprite_point(int(self))(i + 1, 1);
        enigma::varaccess_sprite_solid(int(self))(i)= enigma::varaccess_sprite_solid(int(self))(i + 1);
        enigma::varaccess_sprite(int(self))(i)= enigma::varaccess_sprite(int(self))(i + 1);
        enigma::varaccess_sprite_offset(int(self))(i)= enigma::varaccess_sprite_offset(int(self))(i + 1);
        enigma::varaccess_sprite_image(int(self))(i)= enigma::varaccess_sprite_image(int(self))(i + 1);
        enigma::varaccess_sprite_transparent(int(self))(i)= enigma::varaccess_sprite_transparent(int(self))(i + 1);
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_physics_angle(variant argument0, variant argument1)
{
  
  {
    var result;
    result = argument1 - argument0;
    if(result > 180)
      result -= 360;
    if(result < - 180)
      result += 360;
    return result;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    
    {
      physics_system_init();
      physics_init();
      physics_import(get_open_filename("All File Types|*.*", working_directory + "\\filename"), 2, 1, x, y);
      physics_settings(0.9);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::myevent_step()
{
  enigma::propagate_locals(this);

  {
    
    {
      if(keyboard_check(vk_up))
        physics_motion(0, point_numb, 0, - 1);
      if(keyboard_check(vk_down))
        physics_motion(0, point_numb, 0, 1);
      if(keyboard_check(vk_left))
        physics_motion(0, point_numb, - 1, 0);
      if(keyboard_check(vk_right))
        physics_motion(0, point_numb, 1, 0);
      physics_motion(0, point_numb, 0, 0.1);
      physics_step();
      room_caption ="Physics Example (Fps: "+ toString(fps)+ ")";
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::myevent_draw()
{
  if (!(visible)) return 0;
image_index = fmod(image_index + image_speed, sprite_get_number(sprite_index));

  {
    
    {
      physics_draw(1, 1, 0);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::_SCR_physics_draw(variant argument0, variant argument1, variant argument2)
{
  
  {
    var i;
    draw_set_color(c_black);
    if(argument0)
      for(i = 0; i < point_numb; i += 1)
        draw_circle(point_x(i), point_y(i), enigma_max(3, point_radius(i) ), 0);
    if(argument1)
      for(i = 0; i < joint_numb; i += 1)
        draw_line(point_x(joint_point(i, 0)), point_y(joint_point(i, 0)), point_x(joint_point(i, 1)), point_y(joint_point(i, 1)) );
    draw_set_halign(fa_center);
    draw_set_color(c_red);
    if(argument2)
      for(i = 0; i < point_numb; i += 1)
        draw_text(point_x(i), point_y(i) - 20, toString(i));
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::_SCR_physics_import(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  
  {
    var i, image, transparent, file, enigmawidth, enigmaheight, width2, height2;
    file = file_text_open_read(argument0);
    width2 = real(file_text_read_string(file));
    file_text_readln(file);
    height2 = real(file_text_read_string(file));
    file_text_readln(file);
    point_numb = real(file_text_read_string(file));
    file_text_readln(file);
    for(i = 0; i < point_numb; i += 1)
    {
      point_x(i)= real(file_text_read_string(file));
      file_text_readln(file);
      point_y(i)= real(file_text_read_string(file));
      file_text_readln(file);
      point_stationary(i)= real(file_text_read_string(file));
      file_text_readln(file);
      point_radius(i)= real(file_text_read_string(file));
      file_text_readln(file);
      point_friction(i)= real(file_text_read_string(file));
      file_text_readln(file);
      
    }
    joint_numb = real(file_text_read_string(file));
    file_text_readln(file);
    for(i = 0; i < joint_numb; i += 1)
    {
      joint_point(i, 0)= real(file_text_read_string(file));
      file_text_readln(file);
      joint_point(i, 1)= real(file_text_read_string(file));
      file_text_readln(file);
      joint_min(i)= real(file_text_read_string(file));
      file_text_readln(file);
      joint_max(i)= real(file_text_read_string(file));
      file_text_readln(file);
      joint_dist(i)= point_distance(point_x(joint_point(i, 0)), point_y(joint_point(i, 0)), point_x(joint_point(i, 1)), point_y(joint_point(i, 1)) );
      
    }
    sprite_numb = real(file_text_read_string(file));
    file_text_readln(file);
    for(i = 0; i < sprite_numb; i += 1)
    {
      sprite_point(i, 0)= real(file_text_read_string(file));
      file_text_readln(file);
      sprite_point(i, 1)= real(file_text_read_string(file));
      file_text_readln(file);
      sprite_solid(i)= real(file_text_read_string(file));
      file_text_readln(file);
      if(sprite_solid(i) )
        sprite(i)= instance_create(0, 0, obj_solid);
      else sprite(i)= instance_create(0, 0, obj_sprite);
      sprite_image(i)= file_text_read_string(file);
      file_text_readln(file);
      sprite_transparent(i)= real(file_text_read_string(file));
      file_text_readln(file);
      enigma::glaccess(int(sprite(i) ))-> sprite_index = sprite_add(working_directory + "\\"+ sprite_image(i), 1, 1, sprite_transparent(i), 0, 0, 0, 0);
      enigmawidth = enigma::varaccess_sprite_width(int(sprite(i) ));
      enigmaheight = enigma::varaccess_sprite_height(int(sprite(i) ));
      sprite_set_offset(enigma::glaccess(int(sprite(i) ))-> sprite_index, enigmawidth / (double) 2, enigmaheight / (double) 2);
      sprite_offset(i)= real(file_text_read_string(file));
      file_text_readln(file);
      
    }
    file_text_close(file);
    for(i = 0; i < point_numb; i += 1)
    {
      if(argument1 == 2)
        point_x(i) -= width2 / (double) 2;
      if(argument1 == 3)
        point_x(i) -= width2;
      if(argument2 == 2)
        point_y(i) -= height2 / (double) 2;
      if(argument2 == 3)
        point_y(i) -= height2;
      point_x(i) += argument3;
      point_y(i) += argument4;
      
    }
    for(i = 0; i < point_numb; i += 1)
    {
      point_x_prev(i)= point_x(i);
      point_y_prev(i)= point_y(i);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::_SCR_physics_init()
{
  
  {
    enigma::varaccess_object(int(global))(enigma::varaccess_object_number(int(global)))= id;
    enigma::varaccess_object_number(int(global))+= 1;
    strength = 0.9;
    point_numb = 0;
    joint_numb = 0;
    sprite_numb = 0;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::_SCR_physics_motion(variant argument0, variant argument1, variant argument2, variant argument3)
{
  
  {
    var i;
    for(i = argument0; i < argument0 + argument1; i += 1)
    {
      point_x_prev(i) -= argument2;
      point_y_prev(i) -= argument3;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::_SCR_physics_settings(variant argument0)
{
  
  {
    strength = argument0;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_object::_SCR_physics_step()
{
  
  {
    var i, ii, iii, x1, y1, x2, y2, xx, yy, lx, ly, temp_x, temp_y, numb, range, collision, temp, dist, diff, dir;
    for(i = 0; i < point_numb; i += 1)
    {
      if(! point_stationary(i) )
      {
        temp_x = point_x(i);
        temp_y = point_y(i);
        point_x(i)= temp_x * 2 - point_x_prev(i);
        point_y(i)= temp_y * 2 - point_y_prev(i);
        point_x_prev(i)= temp_x;
        point_y_prev(i)= temp_y;
        
      }
      
    }
    repeat(5)
    {
      for(i = 0; i < joint_numb; i += 1)
      {
        dist = point_distance(point_x(joint_point(i, 0)), point_y(joint_point(i, 0)), point_x(joint_point(i, 1)), point_y(joint_point(i, 1)) );
        if((dist > joint_dist(i) + joint_max(i) )|| (dist < joint_dist(i) - joint_min(i) ))
        {
          temp = dist;
          if(temp > joint_dist(i) + joint_max(i) )
            dist =((dist - (joint_dist(i) + joint_max(i) ))/ (double) 2)* strength;
          if(temp < joint_dist(i) - joint_min(i) )
            dist =((dist - (joint_dist(i) - joint_min(i) ))/ (double) 2)* strength;
          dir = point_direction(point_x(joint_point(i, 0)), point_y(joint_point(i, 0)), point_x(joint_point(i, 1)), point_y(joint_point(i, 1)) );
          lx = lengthdir_x(dist, dir);
          ly = lengthdir_y(dist, dir);
          if(! point_stationary(joint_point(i, 0)) )
          {
            point_x(joint_point(i, 0)) += lx;
            point_y(joint_point(i, 0)) += ly;
            
          }
          if(! point_stationary(joint_point(i, 1)) )
          {
            point_x(joint_point(i, 1)) -= lx;
            point_y(joint_point(i, 1)) -= ly;
            
          }
          
        }
        else
        {
          dist =((dist - joint_dist(i) )/ (double) 2)* strength * 0.05;
          dir = point_direction(point_x(joint_point(i, 0)), point_y(joint_point(i, 0)), point_x(joint_point(i, 1)), point_y(joint_point(i, 1)) );
          lx = lengthdir_x(dist, dir);
          ly = lengthdir_y(dist, dir);
          if(! point_stationary(joint_point(i, 0)) )
          {
            point_x(joint_point(i, 0)) += lx;
            point_y(joint_point(i, 0)) += ly;
            
          }
          if(! point_stationary(joint_point(i, 1)) )
          {
            point_x(joint_point(i, 1)) -= lx;
            point_y(joint_point(i, 1)) -= ly;
            
          }
          
        }
        
      }
      
    }
    for(i = 0; i < point_numb; i += 1)
    {
      point_collision(i)= 0;
      if(! point_stationary(i) )
        if(collision_circle(point_x(i), point_y(i), point_radius(i), obj_solid, 1, 0))
      {
        point_collision(i)= 1;
        lx = point_x(i) - point_x_prev(i);
        ly = point_y(i) - point_y_prev(i);
        temp = enigma_max(abs(lx), abs(ly));
        lx /= temp;
        ly /= temp;
        temp_x = point_x(i);
        temp_y = point_y(i);
        dist = point_distance(point_x(i), point_y(i), point_x_prev(i), point_y_prev(i) );
        if(lx != 0 || ly != 0)
          while(collision_point(temp_x, temp_y, obj_solid, 1, 0))
        {
          temp_x -= lx;
          temp_y -= ly;
          if(sqr(point_x(i) - temp_x)+ sqr(point_y(i) - temp_y)> sqr(dist)+ 10)
          {
            temp_x = point_x_prev(i);
            temp_y = point_y_prev(i);
            break;
            
          }
          
        }
        numb = 0;
        range = point_radius(i) + 10;
        for(ii =- range; ii < range; ii += 1)
        {
          collision = sign(collision_point(temp_x + ii, temp_y, obj_solid, 1, 0));
          for(iii = 0; iii < 10; iii += 1)
            if(sign(collision_point(temp_x + ii, temp_y + iii, obj_solid, 1, 0))==- collision)
          {
            xx(numb)= temp_x + ii;
            yy(numb)= temp_y + iii - (collision == 1);
            numb += 1;
            break;
            
          }
          for(iii = 0; iii < range / (double) 2; iii += 1)
            if(sign(collision_point(temp_x + ii, temp_y - iii, obj_solid, 1, 0))==- collision)
          {
            xx(numb)= temp_x + ii;
            yy(numb)= temp_y - iii + (collision == 1);
            numb += 1;
            break;
            
          }
          collision = sign(collision_point(temp_x, temp_y + ii, obj_solid, 1, 0));
          for(iii = 0; iii < range / (double) 2; iii += 1)
            if(sign(collision_point(temp_x + iii, temp_y + ii, obj_solid, 1, 0))==- collision)
          {
            xx(numb)= temp_x + iii - (collision == 1);
            yy(numb)= temp_y + ii;
            numb += 1;
            break;
            
          }
          for(iii = 0; iii < range / (double) 2; iii += 1)
            if(sign(collision_point(temp_x - iii, temp_y + ii, obj_solid, 1, 0))==- collision)
          {
            xx(numb)= temp_x - iii + (collision == 1);
            yy(numb)= temp_y + ii;
            numb += 1;
            break;
            
          }
          
        }
        temp(0)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(0) += sqr(xx(ii) );
        temp(1)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(1) += xx(ii);
        lx = numb * temp(0) - sqr(temp(1) );
        temp(0)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(0) += sqr(yy(ii) );
        temp(1)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(1) += yy(ii);
        ly = numb * temp(0) - sqr(temp(1) );
        temp(0)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(0) += xx(ii) * yy(ii);
        temp(1)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(1) += xx(ii);
        temp(2)= 0;
        for(ii = 0; ii < numb; ii += 1)
          temp(2) += yy(ii);
        tempdist = numb * temp(0) - temp(1) * temp(2);
        if(abs(lx)> abs(ly))
          ly = tempdist;
        else lx = tempdist;
        dir = point_direction(0, 0, lx, ly);
        diff = physics_angle(dir, point_direction(point_x(i), point_y(i), point_x_prev(i), point_y_prev(i) ));
        dist = point_distance(point_x(i), point_y(i), point_x_prev(i), point_y_prev(i) );
        lx = lengthdir_x(1, dir + sign(diff)* 90);
        ly = lengthdir_y(1, dir + sign(diff)* 90);
        temp_x = point_x(i);
        temp_y = point_y(i);
        temp = 0;
        while(collision_circle(point_x(i), point_y(i), point_radius(i), obj_solid, 1, 0))
        {
          point_x(i) += lx;
          point_y(i) += ly;
          if(sqr(point_x(i) - temp_x)+ sqr(point_y(i) - temp_y)> sqr(dist)+ 10)
          {
            if(temp)
            {
              point_x(i)= point_x_prev(i);
              point_y(i)= point_y_prev(i);
              break;
              
            }
            lx =- lx;
            ly =- ly;
            point_x(i)= temp_x;
            point_y(i)= temp_y;
            temp = 1;
            
          }
          
        }
        lx = lengthdir_x(1, dir - diff);
        ly = lengthdir_y(1, dir - diff);
        point_x_prev(i)= point_x(i) + lx * dist;
        point_y_prev(i)= point_y(i) + ly * dist;
        
      }
      
    }
    for(i = 0; i < point_numb; i += 1)
    {
      if(point_collision(i) )
      {
        lx = point_x(i) - point_x_prev(i);
        ly = point_y(i) - point_y_prev(i);
        point_x_prev(i)= point_x(i) - lx * (1 - point_friction(i) );
        point_y_prev(i)= point_y(i) - ly * (1 - point_friction(i) );
        
      }
      
    }
    for(i = 0; i < sprite_numb; i += 1)
    {
      x1 = point_x(sprite_point(i, 0));
      y1 = point_y(sprite_point(i, 0));
      x2 = point_x(sprite_point(i, 1));
      y2 = point_y(sprite_point(i, 1));
      enigma::glaccess(int(sprite(i) ))-> x =(x1 + x2)/ (double) 2;
      enigma::glaccess(int(sprite(i) ))-> y =(y1 + y2)/ (double) 2;
      enigma::glaccess(int(sprite(i) ))-> image_angle = point_direction(x1, y1, x2, y2)+ sprite_offset(i);
      
    }
    
  }
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
