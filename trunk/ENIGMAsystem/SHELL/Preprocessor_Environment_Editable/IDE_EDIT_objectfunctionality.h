/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant _SCR_contra_text(variant argument0, variant argument1, variant argument2)
{
  with(self)
  {
    var length, text;
    draw_set_font(enigma::varaccess_contrafont(int(global)));
    draw_set_color(c_white);
    enigma::varaccess_x1(int(self))= argument0;
    enigma::varaccess_y1(int(self))= argument1 - 18;
    text = argument2;
    length =(string_length(text)* 14)/ (double) 128;
    enigmadraw_text(enigma::varaccess_x1(int(self))+ length, enigma::varaccess_y1(int(self)), text);
    
  }
  ;
  
  return 0;
}

variant _SCR_spreadgun_3D()
{
  with(self)
  {
    for(enigma::varaccess_i(int(self))= 0; enigma::varaccess_i(int(self))< 5; enigma::varaccess_i(int(self))+= 1)
    {
      enigma::varaccess_ammo(int(self))= instance_create(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 90, obj_bullet_3D);
      if(enigma::varaccess_i(int(self))== 0)
      {
        enigma::varaccess_other_hspeed(int(enigma::varaccess_ammo(int(self))))= 0;
        
      }
      else if(enigma::varaccess_i(int(self))mod 2 == 0)
      {
        enigma::varaccess_other_hspeed(int(enigma::varaccess_ammo(int(self))))= enigma::varaccess_i(int(self))* 1.5;
        
      }
      else
      {
        enigma::varaccess_other_hspeed(int(enigma::varaccess_ammo(int(self))))=- enigma::varaccess_i(int(self))* 1.5;
        
      }
      enigma::varaccess_other_x(int(enigma::varaccess_ammo(int(self))))= enigma::glaccess(int(obj_player_3D))-> x;
      enigma::glaccess(int(enigma::varaccess_ammo(int(self))))-> sprite_index = spr_spread_bullet;
      enigma::glaccess(int(enigma::varaccess_ammo(int(self))))-> vspeed =- 5;
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_machinegun_3D()
{
  with(self)
  {
    enigma::varaccess_center(int(self))= room_width / (double) 2;
    enigma::varaccess_size2(int(self))= 384;
    enigma::varaccess_size1(int(self))= 128;
    enigma::varaccess_Y(int(self))= enigma::glaccess(int(self))-> y + 300;
    enigma::varaccess_a0(int(self))= enigma::varaccess_center(int(self))- enigma::varaccess_size1(int(self));
    enigma::varaccess_a1(int(self))= enigma::varaccess_center(int(self))+ enigma::varaccess_size1(int(self));
    enigma::varaccess_b0(int(self))= enigma::varaccess_center(int(self))- enigma::varaccess_size2(int(self));
    enigma::varaccess_b1(int(self))= enigma::varaccess_center(int(self))+ enigma::varaccess_size2(int(self));
    enigma::varaccess_p1(int(self))= enigma::glaccess(int(self))-> x;
    enigma::varaccess_p2(int(self))=((enigma::varaccess_p1(int(self))- enigma::varaccess_a0(int(self)))/ (double)(enigma::varaccess_a1(int(self))- enigma::varaccess_a0(int(self))))* (enigma::varaccess_b1(int(self))- enigma::varaccess_b0(int(self)))+ enigma::varaccess_b0(int(self));
    enigma::varaccess_ammo(int(self))= instance_create(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 90, obj_bullet_3D);
    enigma::glaccess(int(enigma::varaccess_ammo(int(self))))-> direction = point_direction(enigma::varaccess_p2(int(self)), enigma::varaccess_Y(int(self)), enigma::varaccess_p1(int(self)), enigma::glaccess(int(obj_player_3D))-> y);
    enigma::glaccess(int(enigma::varaccess_ammo(int(self))))-> speed = 5;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_player_3D::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    image_speed = 0.2;
    lives = 2;
    floor_coord(0)= 192;
    floor_coord(1)= 320;
    floor_coord(2)= 240;
    floor_coord(3)= 64;
    floor_coord(4)= 448;
    floor_coord(5)= 368;
    starty = y;
    sound_play(base_intro);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_player_3D::myevent_alarm_0()
{
  { if ((alarm[0] == -1) or (alarm[0]--)) return 0; }

  {
    if(! keyboard_check(vk_up))
    {
      zapped = 0;
      y = starty;
      
    }
    else
    {
      alarm[0]= 20;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_player_3D::myevent_step()
{
  enigma::propagate_locals(this);

  {
    leftside = floor_coord(3) + (floor_coord(0) - floor_coord(3) )/ (double)(floor_coord(2) - floor_coord(5) )* (y - floor_coord(5) );
    rightside = floor_coord(4) + (floor_coord(1) - floor_coord(4) )/ (double)(floor_coord(2) - floor_coord(5) )* (y - floor_coord(5) );
    vspeed = enigma_min(vspeed, 6);
    if(y < starty && jumping == 1)
    {
      gravity = 0.5;
      
    }
    else if(y >= starty)
    {
      gravity = 0;
      vspeed = 0;
      y = starty;
      jumping = 0;
      
    }
    if(keyboard_check_pressed(ord("X"))
      && jumping == 0 && zapped == 0 && ! keyboard_check(vk_down))
    {
      vspeed =- 11.2;
      jumping = 1;
      
    }
    if(jumping == 0 && ! keyboard_check(vk_down))
    {
      x = enigma_max(enigma_min(x, rightside - 48), leftside + 48);
      y = enigma_max(enigma_min(y, room_height), floor_coord(2) + 94);
      if(keyboard_check(vk_up)&& y > floor_coord(2) + 94)
      {
        vspeed =- 2;
        
      }
      else if(y <= floor_coord(2) + 94)
      {
        vspeed = 0;
        y = starty;
        if(i < 3)
        {
          i += 1;
          background_visible(i)= 1;
          background_visible(i - 1)= 0;
          
        }
        else
        {
          room_restart();
          
        }
        
      }
      if(vspeed == 0 && y == starty && zapped == 0)
      {
        if(keyboard_check(vk_right)&& keyboard_check(vk_left))
        {
          sprite_index = spr_greg_shoot_idle_3D;
          hspeed = 0;
          
        }
        else if(keyboard_check(vk_right)&& ! keyboard_check(vk_up))
        {
          if(shooting == 1)
          {
            sprite_index = spr_greg_shoot_run_R_3D;
            
          }
          else
          {
            sprite_index = spr_greg_run_R;
            
          }
          hspeed = 3.5;
          
        }
        else if(keyboard_check(vk_left)&& ! keyboard_check(vk_up))
        {
          if(shooting == 1)
          {
            sprite_index = spr_greg_shoot_run_L_3D;
            
          }
          else
          {
            sprite_index = spr_greg_run_L;
            
          }
          hspeed =- 3.5;
          
        }
        else
        {
          sprite_index = spr_greg_shoot_idle_3D;
          hspeed = 0;
          
        }
        
      }
      else if(y != starty && instance_exists(obj_electricity)&& jumping == 0)
      {
        sprite_index = spr_greg_electrified_3D;
        vspeed = 0;
        hspeed = 0;
        if(zapped == 0)
        {
          alarm[0]= 20;
          zapped = 1;
          
        }
        
      }
      else
      {
        sprite_index = spr_greg_run_3D;
        
      }
      
    }
    else if(keyboard_check(vk_down)&& jumping == 0)
    {
      sprite_index = spr_greg_shoot_down_3D;
      hspeed = 0;
      
    }
    else
    {
      x = enigma_max(enigma_min(x, floor_coord(4) - 48), floor_coord(3) + 48);
      y = enigma_max(enigma_min(y, room_height), 0);
      sprite_index = spr_greg_jump;
      if(keyboard_check(vk_right))
      {
        hspeed = 2;
        
      }
      else if(keyboard_check(vk_left))
      {
        hspeed =- 2;
        
      }
      
    }
    if((sprite_index == spr_greg_shoot_idle_3D || sprite_index == spr_greg_shoot_down_3D)&& shooting == 0)
    {
      image_speed = 0;
      
    }
    else
    {
      image_speed = 0.2;
      
    }
    
  }
  
  {
    if(keyboard_check_pressed(ord("Z"))
      && zapped == 0)
    {
      spreadgun_3D();
      
    }
    if(image_index > image_number - 1 && shooting == 1)
    {
      shooting = 0;
      image_index = 0;
      
    }
    
  }
  
  {
    room_caption = toString(shooting);
    if(! sound_isplaying(base_intro)&& ! sound_isplaying(base))
    {
      sound_loop(base);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_player_3D::myevent_draw()
{
  if (!(visible)) return 0;
image_index = fmod(image_index + image_speed, sprite_get_number(sprite_index));

  {
    draw_sprite(sprite_index, - 1, x, y);
    for(i = 0; i < lives; i += 1)
    {
      draw_sprite(spr_greg_life, 0, (view_xview[0] + 35)+ sprite_get_width(spr_greg_life)* i * 1.5, view_yview[0] + 15);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_player_3D::_SCR_spreadgun_3D()
{
  for(i = 0; i < 5; i += 1)
  {
    ammo = instance_create(x, y - 90, obj_bullet_3D);
    if(i == 0)
    {
      enigma::varaccess_other_hspeed(int(ammo))= 0;
      
    }
    else if(i mod 2 == 0)
    {
      enigma::varaccess_other_hspeed(int(ammo))= i * 1.5;
      
    }
    else
    {
      enigma::varaccess_other_hspeed(int(ammo))=- i * 1.5;
      
    }
    enigma::varaccess_other_x(int(ammo))= enigma::glaccess(int(obj_player_3D))-> x;
    enigma::glaccess(int(ammo))-> sprite_index = spr_spread_bullet;
    enigma::glaccess(int(ammo))-> vspeed =- 5;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_bullet_3D::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(y < 192)
    {
      instance_destroy();
      
    }
    if(sprite_index == spr_spread_bullet)
    {
      other_x += other_hspeed;
      x =(other_x - 256)* (y - 176)/ (double) 184 + 256;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_select::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    visible = 0;
    x = 87;
    y = 310;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_select::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(keyboard_check(vk_enter))
    {
      room_goto_next();
      
    }
    if(enigma::glaccess(int(obj_background))-> speed == 0)
    {
      visible = 1;
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_background::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    move_towards_point(1, y, 5);
    enigma::varaccess_contrafont(int(global))= font_add_sprite(spr_font, ord(" "), 1, 4);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_background::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(distance_to_point(1, y)< speed)
    {
      x = 1;
      y = y;
      speed = 0;
      
    }
    
  }
  
  {
    if(speed == 0 and ! instance_exists(obj_char_image))
    {
      instance_create(279, 244, obj_char_image);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_background::myevent_draw()
{
  if (!(visible)) return 0;
image_index = fmod(image_index + image_speed, sprite_get_number(sprite_index));

  {
    draw_sprite(sprite_index, - 1, x, y);
    draw_set_alpha(0.8);
    draw_sprite(sprite_index, - 1, x, y);
    contra_text(x + 40, y + 220, "JOIN THE ARMY: OPERATION SWEDEN");
    contra_text(x + 80, y + 280, "Player Select");
    contra_text(x + 120, y + 320, "Greg");
    contra_text(x + 120, y + 350, "Trevor");
    contra_text(x + 160, y + 384, "TM and $ 2006-11");
    contra_text(x + 120, y + 400, "Greg and Trevor Games");
    contra_text(x + 134, y + 416, "Made with LateralGM");
    contra_text(x + 205, y + 432, "and ENIGMA");
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_background::_SCR_contra_text(variant argument0, variant argument1, variant argument2)
{
  var length, text;
  draw_set_font(enigma::varaccess_contrafont(int(global)));
  draw_set_color(c_white);
  x1 = argument0;
  y1 = argument1 - 18;
  text = argument2;
  length =(string_length(text)* 14)/ (double) 128;
  enigmadraw_text(x1 + length, y1, text);
  
  return 0;
}

variant enigma::OBJ_obj_electricity::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    image_speed = 0.2;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_electricity::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(background_visible(0)== 0 or keyboard_check(ord("E"))
      )
    {
      instance_destroy();
      
    }
    
  }
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
    { NULL, -1 },
    { NULL, -1 },
    { NULL, -1 },
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
