/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant _SCR_draw_map(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  with(self)
  {
    var i, arg0, arg1, arg2, arg3, arg4;
    arg0 = argument0;
    arg1 = argument1;
    arg2 = argument2;
    arg3 = argument3;
    arg4 = argument4;
    enigma::varaccess_pen_color(int(self))= c_black;
    enigma::varaccess_brush_color(int(self))= c_green;
    draw_rectangle(argument0, argument1, argument0 + argument2, argument1 + argument3);
    with(obj_friend)
    {
      with(other)
      {
        enigma::varaccess_pen_color(int(self))= c_blue;
        enigma::varaccess_brush_color(int(self))= c_blue;
        draw_circle(arg0 + enigma::glaccess(int(other))-> x / (double)(room_width / (double) arg2), arg1 + enigma::glaccess(int(other))-> y / (double)(room_height / (double) arg3), arg4);
        
      }
      
    }
    with(obj_enemy)
    {
      with(other)
      {
        enigma::varaccess_pen_color(int(self))= c_red;
        enigma::varaccess_brush_color(int(self))= c_red;
        draw_circle(arg0 + enigma::glaccess(int(other))-> x / (double)(room_width / (double) arg2), arg1 + enigma::glaccess(int(other))-> y / (double)(room_height / (double) arg3), arg4);
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_camera::myevent_step()
{
  enigma::propagate_locals(this);

  {
    if(mouse_button == mb_left)
    {
      show_message("mouse_button");
      if(place_empty(mouse_x, mouse_y))
        instance_create(mouse_x, mouse_y, obj_enemy);
      
    }
    if(mouse_button == mb_right)
    {
      if(place_empty(mouse_x, mouse_y))
        instance_create(mouse_x, mouse_y, obj_friend);
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_camera::myevent_keyboard_37()
{
  
  {
    view_left(0) -= 10;
    if(view_left(0) < 0)
      view_left(0)= 0;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_camera::myevent_keyboard_38()
{
  
  {
    view_top(0) -= 10;
    if(view_top(0) < 0)
      view_top(0)= 0;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_camera::myevent_keyboard_39()
{
  
  {
    view_left(0) += 10;
    if(view_left(0) > room_width - view_width(0) )
      view_left(0)= room_width - view_width(0);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_camera::myevent_keyboard_40()
{
  
  {
    view_top(0) += 10;
    if(view_top(0) > room_height - view_height(0) )
      view_top(0)= room_height - view_height(0);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_enemy::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    side ="enemy";
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_friend::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  
  {
    side ="friend";
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_map::myevent_draw()
{
  if (!(visible)) return 0;
image_index = fmod(image_index + image_speed, sprite_get_number(sprite_index));

  {
    draw_map(view_left, view_top, 200, 200, 2);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_map::_SCR_draw_map(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  var i, arg0, arg1, arg2, arg3, arg4;
  arg0 = argument0;
  arg1 = argument1;
  arg2 = argument2;
  arg3 = argument3;
  arg4 = argument4;
  pen_color = c_black;
  brush_color = c_green;
  draw_rectangle(argument0, argument1, argument0 + argument2, argument1 + argument3);
  with(obj_friend)
  {
    with(other)
    {
      enigma::varaccess_pen_color(int(self))= c_blue;
      enigma::varaccess_brush_color(int(self))= c_blue;
      draw_circle(arg0 + enigma::glaccess(int(other))-> x / (double)(room_width / (double) arg2), arg1 + enigma::glaccess(int(other))-> y / (double)(room_height / (double) arg3), arg4);
      
    }
    
  }
  with(obj_enemy)
  {
    with(other)
    {
      enigma::varaccess_pen_color(int(self))= c_red;
      enigma::varaccess_brush_color(int(self))= c_red;
      draw_circle(arg0 + enigma::glaccess(int(other))-> x / (double)(room_width / (double) arg2), arg1 + enigma::glaccess(int(other))-> y / (double)(room_height / (double) arg3), arg4);
      
    }
    
  }
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
    { NULL, -1 },
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
