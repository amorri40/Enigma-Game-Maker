/********************************************************************************\
**                                                                              **
**  Copyright (C) 2008 Josh Ventura                                             **
**                                                                              **
**  This file is a part of the ENIGMA Development Environment.                  **
**                                                                              **
**                                                                              **
**  ENIGMA is free software: you can redistribute it and/or modify it under the **
**  terms of the GNU General Public License as published by the Free Software   **
**  Foundation, version 3 of the license or any later version.                  **
**                                                                              **
**  This application and its source code is distributed AS-IS, WITHOUT ANY      **
**  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS   **
**  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more       **
**  details.                                                                    **
**                                                                              **
**  You should have recieved a copy of the GNU General Public License along     **
**  with this code. If not, see <http://www.gnu.org/licenses/>                  **
**                                                                              **
**  ENIGMA is an environment designed to create games and other programs with a **
**  high-level, fully compilable language. Developers of ENIGMA or anything     **
**  associated with ENIGMA are in no way responsible for its users or           **
**  applications created by its users, or damages caused by the environment     **
**  or programs made in the environment.                                        **
**                                                                              **
\********************************************************************************/

//This file was generated by the ENIGMA Development Environment.
//Editing it is a sign of a certain medical condition. We're not sure which one.

variant _SCR_move_lhr(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  with(self)
  {
    if(enigma::glaccess(int(self))-> image_index == 0)
    {
      if(! enigma::varaccess_turned(int(self))&& (enigma::glaccess(int(self))-> y > 0)&& place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 32))
      {
        enigma::glaccess(int(self))-> image_index += 1;
        enigma::varaccess_turned(int(self))= 1;
        
      }
      else
      {
        enigma::varaccess_turned(int(self))= 0;
        if((enigma::glaccess(int(self))-> x + 32 < room_width)&& place_free(enigma::glaccess(int(self))-> x + 32, enigma::glaccess(int(self))-> y))
        {
          enigma::glaccess(int(self))-> x += 32;
          
        }
        else if((enigma::glaccess(int(self))-> y == 0)|| ! place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 32))
        {
          enigma::glaccess(int(self))-> image_index = 3;
          
        }
        else
        {
          enigma::glaccess(int(self))-> image_index += 1;
          
        }
        
      }
      
    }
    else if(enigma::glaccess(int(self))-> image_index == 1)
    {
      if(! enigma::varaccess_turned(int(self))&& (enigma::glaccess(int(self))-> x > 0)&& place_free(enigma::glaccess(int(self))-> x - 32, enigma::glaccess(int(self))-> y))
      {
        enigma::glaccess(int(self))-> image_index += 1;
        enigma::varaccess_turned(int(self))= 1;
        
      }
      else
      {
        enigma::varaccess_turned(int(self))= 0;
        if((enigma::glaccess(int(self))-> y > 0)&& place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 32))
        {
          enigma::glaccess(int(self))-> y -= 32;
          
        }
        else if((enigma::glaccess(int(self))-> x == 0)|| ! place_free(enigma::glaccess(int(self))-> x - 32, enigma::glaccess(int(self))-> y))
        {
          enigma::glaccess(int(self))-> image_index -= 1;
          
        }
        else
        {
          enigma::glaccess(int(self))-> image_index += 1;
          
        }
        
      }
      
    }
    else if(enigma::glaccess(int(self))-> image_index == 2)
    {
      if(! enigma::varaccess_turned(int(self))&& (enigma::glaccess(int(self))-> y + 32 < room_height)&& place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y + 32))
      {
        enigma::glaccess(int(self))-> image_index += 1;
        enigma::varaccess_turned(int(self))= 1;
        
      }
      else
      {
        enigma::varaccess_turned(int(self))= 0;
        if((enigma::glaccess(int(self))-> x > 0)&& place_free(enigma::glaccess(int(self))-> x - 32, enigma::glaccess(int(self))-> y))
        {
          enigma::glaccess(int(self))-> x -= 32;
          
        }
        else if((enigma::glaccess(int(self))-> y + 32 >= room_height)|| ! place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y + 32))
        {
          enigma::glaccess(int(self))-> image_index -= 1;
          
        }
        else
        {
          enigma::glaccess(int(self))-> image_index += 1;
          
        }
        
      }
      
    }
    else if(enigma::glaccess(int(self))-> image_index == 3)
    {
      if(! enigma::varaccess_turned(int(self))&& (enigma::glaccess(int(self))-> x + 32 < room_width)&& place_free(enigma::glaccess(int(self))-> x + 32, enigma::glaccess(int(self))-> y))
      {
        enigma::glaccess(int(self))-> image_index = 0;
        enigma::varaccess_turned(int(self))= 1;
        
      }
      else
      {
        enigma::varaccess_turned(int(self))= 0;
        if((enigma::glaccess(int(self))-> y + 32 < room_height)&& place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y + 32))
        {
          enigma::glaccess(int(self))-> y += 32;
          
        }
        else if((enigma::glaccess(int(self))-> x + 32 >= room_width)|| ! place_free(enigma::glaccess(int(self))-> x + 32, enigma::glaccess(int(self))-> y))
        {
          enigma::glaccess(int(self))-> image_index -= 1;
          
        }
        else
        {
          enigma::glaccess(int(self))-> image_index = 0;
          
        }
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_move_mouse1()
{
  with(self)
  {
    enigma::varaccess_mx(int(self))= floor(mouse_x / (double) 32);
    enigma::varaccess_my(int(self))= floor(mouse_y / (double) 32);
    enigma::varaccess_px(int(self))= floor(enigma::glaccess(int(self))-> x / (double) 32);
    enigma::varaccess_py(int(self))= floor(enigma::glaccess(int(self))-> y / (double) 32);
    enigma::varaccess_pf(int(self))= place_free(enigma::varaccess_mx(int(self))* 32, enigma::varaccess_my(int(self))* 32);
    enigma::varaccess_xv(int(self))= mouse_x > 0 && mouse_x < room_width;
    enigma::varaccess_yv(int(self))= mouse_y > 0 && mouse_y < room_height;
    enigma::varaccess_dg(int(self))=(enigma::varaccess_mx(int(self))!= enigma::varaccess_px(int(self))&& enigma::varaccess_my(int(self))!= enigma::varaccess_py(int(self)));
    if(enigma::varaccess_pf(int(self))&& enigma::varaccess_xv(int(self))&& enigma::varaccess_yv(int(self))&& ! enigma::varaccess_dg(int(self)))
    {
      if(enigma::varaccess_mx(int(self))== enigma::varaccess_px(int(self))+ 1)
        enigma::glaccess(int(self))-> x += 32;
      else if(enigma::varaccess_mx(int(self))== enigma::varaccess_px(int(self))- 1)
        enigma::glaccess(int(self))-> x -= 32;
      else if(enigma::varaccess_my(int(self))== enigma::varaccess_py(int(self))+ 1)
        enigma::glaccess(int(self))-> y += 32;
      else if(enigma::varaccess_my(int(self))== enigma::varaccess_py(int(self))- 1)
        enigma::glaccess(int(self))-> y -= 32;
      
    }
    
  }
  ;
  
  return 0;
}

variant _SCR_move_towards_mouse()
{
  with(self)
  {
    if(mouse_x > enigma::glaccess(int(self))-> x && mouse_y > enigma::glaccess(int(self))-> y && mouse_x < enigma::glaccess(int(self))-> x + 32 && mouse_y < enigma::glaccess(int(self))-> y + 32)
    {
      return 0;
      
    }
    enigma::varaccess_dir(int(self))= round(point_direction(enigma::glaccess(int(self))-> x + 16, enigma::glaccess(int(self))-> y + 16, mouse_x, mouse_y)/ (double) 90);
    if(enigma::varaccess_dir(int(self))==- 1)
      enigma::varaccess_dir(int(self))= 3;
    if(enigma::varaccess_dir(int(self))== 4)
      enigma::varaccess_dir(int(self))= 0;
    if(enigma::varaccess_dir(int(self))== 0 && enigma::glaccess(int(self))-> x + 32 < room_width && place_free(enigma::glaccess(int(self))-> x + 32, enigma::glaccess(int(self))-> y))
      enigma::glaccess(int(self))-> x += 32;
    if(enigma::varaccess_dir(int(self))== 1 && enigma::glaccess(int(self))-> y > 0 && place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 32))
      enigma::glaccess(int(self))-> y -= 32;
    if(enigma::varaccess_dir(int(self))== 2 && enigma::glaccess(int(self))-> x > 0 && place_free(enigma::glaccess(int(self))-> x - 32, enigma::glaccess(int(self))-> y))
      enigma::glaccess(int(self))-> x -= 32;
    if(enigma::varaccess_dir(int(self))== 3 && enigma::glaccess(int(self))-> y + 32 < room_height && place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y + 32))
      enigma::glaccess(int(self))-> y += 32;
    enigma::glaccess(int(self))-> image_speed = 0;
    enigma::glaccess(int(self))-> image_index = enigma::varaccess_dir(int(self));
    
  }
  ;
  
  return 0;
}

variant _SCR_slide_towards_mouse(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  with(self)
  {
    enigma::varaccess_xx(int(self))= enigma::glaccess(int(self))-> x;
    enigma::varaccess_yy(int(self))= enigma::glaccess(int(self))-> y;
    move_towards_mouse();
    if(enigma::varaccess_xx(int(self))!= enigma::glaccess(int(self))-> x || enigma::varaccess_yy(int(self))!= enigma::glaccess(int(self))-> y)
      return 0;
    if(enigma::glaccess(int(self))-> x + 32 < mouse_x && place_free(enigma::glaccess(int(self))-> x + 32, enigma::glaccess(int(self))-> y)&& enigma::glaccess(int(self))-> x + 32 < room_width)
      enigma::glaccess(int(self))-> x += 32;
    else if(enigma::glaccess(int(self))-> y + 32 < mouse_y && place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y + 32)&& enigma::glaccess(int(self))-> y + 32 < room_height)
      enigma::glaccess(int(self))-> y += 32;
    else if(enigma::glaccess(int(self))-> x > mouse_x && place_free(enigma::glaccess(int(self))-> x - 32, enigma::glaccess(int(self))-> y)&& enigma::glaccess(int(self))-> x > 0)
      enigma::glaccess(int(self))-> x -= 32;
    else if(enigma::glaccess(int(self))-> y > mouse_y && place_free(enigma::glaccess(int(self))-> x, enigma::glaccess(int(self))-> y - 32)&& enigma::glaccess(int(self))-> y > 0)
      enigma::glaccess(int(self))-> y -= 32;
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_bot::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  action_sprite_set(spr_player, 3, 0);
  turned = 0;
  
  {
    argument_relative = 0;
    if(argument_relative)
      alarm[ (0)] +=(15);
    else alarm[ (0)]=(15);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_bot::myevent_alarm_0()
{
  { if ((alarm[0] == -1) or (alarm[0]--)) return 0; }
move_lhr((0), (0), (0), (0), (0));
  
  {
    argument_relative = 0;
    if(argument_relative)
      alarm[ (0)] +=(15);
    else alarm[ (0)]=(15);
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_bot::_SCR_move_lhr(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  if(image_index == 0)
  {
    if(! turned && (y > 0)&& place_free(x, y - 32))
    {
      image_index += 1;
      turned = 1;
      
    }
    else
    {
      turned = 0;
      if((x + 32 < room_width)&& place_free(x + 32, y))
      {
        x += 32;
        
      }
      else if((y == 0)|| ! place_free(x, y - 32))
      {
        image_index = 3;
        
      }
      else
      {
        image_index += 1;
        
      }
      
    }
    
  }
  else if(image_index == 1)
  {
    if(! turned && (x > 0)&& place_free(x - 32, y))
    {
      image_index += 1;
      turned = 1;
      
    }
    else
    {
      turned = 0;
      if((y > 0)&& place_free(x, y - 32))
      {
        y -= 32;
        
      }
      else if((x == 0)|| ! place_free(x - 32, y))
      {
        image_index -= 1;
        
      }
      else
      {
        image_index += 1;
        
      }
      
    }
    
  }
  else if(image_index == 2)
  {
    if(! turned && (y + 32 < room_height)&& place_free(x, y + 32))
    {
      image_index += 1;
      turned = 1;
      
    }
    else
    {
      turned = 0;
      if((x > 0)&& place_free(x - 32, y))
      {
        x -= 32;
        
      }
      else if((y + 32 >= room_height)|| ! place_free(x, y + 32))
      {
        image_index -= 1;
        
      }
      else
      {
        image_index += 1;
        
      }
      
    }
    
  }
  else if(image_index == 3)
  {
    if(! turned && (x + 32 < room_width)&& place_free(x + 32, y))
    {
      image_index = 0;
      turned = 1;
      
    }
    else
    {
      turned = 0;
      if((y + 32 < room_height)&& place_free(x, y + 32))
      {
        y += 32;
        
      }
      else if((x + 32 >= room_width)|| ! place_free(x + 32, y))
      {
        image_index -= 1;
        
      }
      else
      {
        image_index = 0;
        
      }
      
    }
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_exit::myevent_collision_6()
{
  if (!((instance_other = enigma::place_meeting_inst(x,y,6)))) return 0;
if (solid ||  enigma::glaccess(int(other))->solid) {x=xprevious; y=yprevious;}
if(action_if_number(obj_food, 0, 0))
  {
    action_sound(snd_pew, 0);
    action_kill_object();
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_exit::myevent_collision_3()
{
  if (!((instance_other = enigma::place_meeting_inst(x,y,3)))) return 0;
if (solid ||  enigma::glaccess(int(other))->solid) {x=xprevious; y=yprevious;}
if(action_if_number(obj_food, 0, 0))
  {
    action_sound(snd_pew, 0);
    action_kill_object();
    
  }
  ;
  
  return 0;
}

variant enigma::OBJ_obj_food::myevent_collision_3()
{
  if (!((instance_other = enigma::place_meeting_inst(x,y,3)))) return 0;
if (solid ||  enigma::glaccess(int(other))->solid) {x=xprevious; y=yprevious;}
action_sound(snd_pew, 0);
  action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_food::myevent_collision_6()
{
  if (!((instance_other = enigma::place_meeting_inst(x,y,6)))) return 0;
if (solid ||  enigma::glaccess(int(other))->solid) {x=xprevious; y=yprevious;}
action_sound(snd_pew, 0);
  action_kill_object();
  
  return 0;
}

variant enigma::OBJ_obj_player::myevent_step()
{
  enigma::propagate_locals(this);
slide_towards_mouse((0), (0), (0), (0), (0));
  
  return 0;
}

variant enigma::OBJ_obj_player::_SCR_move_towards_mouse()
{
  if(mouse_x > x && mouse_y > y && mouse_x < x + 32 && mouse_y < y + 32)
  {
    return 0;
    
  }
  dir = round(point_direction(x + 16, y + 16, mouse_x, mouse_y)/ (double) 90);
  if(dir ==- 1)
    dir = 3;
  if(dir == 4)
    dir = 0;
  if(dir == 0 && x + 32 < room_width && place_free(x + 32, y))
    x += 32;
  if(dir == 1 && y > 0 && place_free(x, y - 32))
    y -= 32;
  if(dir == 2 && x > 0 && place_free(x - 32, y))
    x -= 32;
  if(dir == 3 && y + 32 < room_height && place_free(x, y + 32))
    y += 32;
  image_speed = 0;
  image_index = dir;
  ;
  
  return 0;
}

variant enigma::OBJ_obj_player::_SCR_slide_towards_mouse(variant argument0, variant argument1, variant argument2, variant argument3, variant argument4)
{
  xx = x;
  yy = y;
  move_towards_mouse();
  if(xx != x || yy != y)
    return 0;
  if(x + 32 < mouse_x && place_free(x + 32, y)&& x + 32 < room_width)
    x += 32;
  else if(y + 32 < mouse_y && place_free(x, y + 32)&& y + 32 < room_height)
    y += 32;
  else if(x > mouse_x && place_free(x - 32, y)&& x > 0)
    x -= 32;
  else if(y > mouse_y && place_free(x, y - 32)&& y > 0)
    y -= 32;
  ;
  
  return 0;
}

variant enigma::OBJ_obj_feeder::myevent_create()
{
  enigma::temp_event_scope ENIGMA_PUSH_ITERATOR_AND_VALIDATE(this);
  for(xx = 0; xx < room_width; xx += 32)
    for(yy = 0; yy < room_height; yy += 32)
      if(place_empty(xx, yy))
        instance_create(xx, yy, obj_food);
  ;
  
  return 0;
}

namespace enigma
{
  callable_script callable_scripts[] = {
    { (variant(*)())_SCR_move_lhr, 5 },
    { (variant(*)())_SCR_move_mouse1, 0 },
    { (variant(*)())_SCR_move_towards_mouse, 0 },
    { (variant(*)())_SCR_slide_towards_mouse, 5 },
  };
  
  void constructor(object_basic* instance_b)
  {
    //This is the universal create event code
    object_locals* instance = (object_locals*)instance_b;
    
    instance->xstart = instance->x;
    instance->ystart = instance->y;
    instance->xprevious = instance->x;
    instance->yprevious = instance->y;

    instance->gravity=0;
    instance->gravity_direction=270;
    instance->friction=0;
    
    
    for(int i=0;i<16;i++)
      instance->alarm[i]=-1;
    
    if(instance->sprite_index!=-1)
    {
      instance->sprite_xoffset = sprite_get_xoffset(instance->sprite_index);
      instance->sprite_yoffset = sprite_get_yoffset(instance->sprite_index);
      
      instance->bbox_left    =   sprite_get_bbox_left(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_right   =  sprite_get_bbox_right(instance->sprite_index)   - instance->sprite_xoffset;
      instance->bbox_top     =   sprite_get_bbox_top (instance->sprite_index)   - instance->sprite_yoffset;
      instance->bbox_bottom  =   sprite_get_bbox_bottom(instance->sprite_index) - instance->sprite_xoffset;
      //instance->sprite_height =  sprite_get_height(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      //instance->sprite_width  =  sprite_get_width(instance->sprite_index);  //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
      instance->image_number  =  sprite_get_number(instance->sprite_index); //TODO: IMPLEMENT THESE AS AN IMPLICIT ACCESSOR
    }
    
    instance->image_alpha = 1.0;
    instance->image_angle = 0;
    instance->image_blend = 0xFFFFFF;
    instance->image_index = 0;
    instance->image_single = -1;
    instance->image_speed  = 1;
    instance->image_xscale = 1;
    instance->image_yscale = 1;
    
instancecount++;
    instance_count++;
  }
}
